[
  {
    "path": "posts/MVT/",
    "title": "Marginalverditeoremet",
    "description": "Eller hvor mye skal jeg handle når jeg handler på nærbutikken?",
    "author": [
      {
        "name": "Endre Grüner Ofstad",
        "url": {}
      }
    ],
    "date": "2023-12-10",
    "categories": [
      "Forvaltning",
      "Økosystem"
    ],
    "contents": "\r\n\r\nContents\r\nMarginalverditeoremet\r\nUtledninger\r\nGenerell løsning\r\nLog-Log\r\n\r\nSimuleringer\r\nSigmoide nyttefunksjoner\r\nCalcagno-gjennomgang (kladd)\r\n\r\nUtledninger for andre nyttefunksjoner\r\nSih 1980\r\nSih 1980 alternativ\r\nÅström mfl 1990 likn. 1\r\nÅström mfl 1990 likn. 2\r\n\r\n\r\n[KLADD]\r\nVi har tidligere pratet om hvordan landskapet oppfattes som en matrise hvor bare noen øyer består av gunstig habitat, og individ beveger seg mellom øyene. Men hvor lenge skal man være på en øy? Eller habitat da. Eller ‘patch’ som det kan kalles på engelsk.\r\n\r\n\r\nShow code\r\n\r\nlibrary(stringr)\r\nlibrary(data.table)\r\nlibrary(ggplot2)\r\nlibrary(cowplot)\r\n\r\nalpha=2\r\nn=1000\r\nx=rep(0,n)\r\ny=rep(0,n)\r\n\r\nfor (i in 2:n){\r\n   theta=runif(1)*2*pi\r\n   f=runif(1)^(-1/alpha)\r\n   x[i]=x[i-1]+f*cos(theta)\r\n   y[i]=y[i-1]+f*sin(theta)\r\n}\r\n\r\nqplot(data = data.frame(x = x, y = y) ,y = y, x = x, geom = \"path\")+\r\n  theme_cowplot()+\r\n  theme(axis.text=element_blank(),axis.title=element_blank(),legend.position = \"none\")\r\n\r\n\r\n\r\nFigure 1: Dyr beveger seg rundt i landskapet. Noen steder oppholder de seg lengre enn andre. Hvorfor det?\r\n\r\n\r\n\r\nMarginalverditeoremet\r\nVed ankomst til habitatet så finner man innledningsvis ny mat ganske lett. Etterhvert som tiden går så blir det mindre og mindre mat igjen, og nytten av å være der øker ikke like raskt som den gjorde innledningsvis. Nytten man oppnår for hvert ekstra tidssteg, altså den marginale verdien, avtar ( se 2a).\r\n\r\nHvis man har brukt lang tid på å komme til habitatet må man oppholde seg der lengre for å veie opp for reisekostnadene. Men hvor mye lengre kommer an på nyttefunksjonen. I 2a viser vi to nyttefunksjoner. Den optimale oppholdstiden kan løses grafisk ved å trekke en linje fra reisetidspunktet (på venstresiden av y-aksen, negative x-verdier) til tangenten av den aktuelle nyttefunksjonen. Den optimale oppholdstiden kan da leses av på x-aksen (vertikale linjer i figur 2b). Slik at jo lengre man reiser dess lengre opphold bør man ha (figur 2c.). Med andre ord, oppholdstid er definert av \\(dG(t = t^*)/dt) = G(t^*)/(T + t^*)\\)\r\n\r\n\r\nShow code\r\n\r\nknitr::opts_chunk$set(fig.width=12, fig.height=8) \r\nMVT = function(BetaTimeSpent=c(.15,.30),x.values = Times){\r\n  library(stringr)\r\n  library(data.table)\r\n  library(ggplot2)\r\n  x = x.values\r\n  lists =  lapply(BetaTimeSpent, function(i){\r\n    fx = deriv(expr = y~x^i,\"x\")\r\n    bs = eval(fx)\r\n    y = bs[seq_along(x)]\r\n    tangents = attr(bs,\"grad\")\r\n    ints = y -tangents*x\r\n    return(data.table(x, y, Slope = tangents, Intercept = ints))})\r\n  datas =    rbindlist(lists)\r\n  names(datas)[3]=\"Tangent\"\r\n  names(datas)[4]=\"xIntercept\"\r\n  betas = rep(BetaTimeSpent, each=length(x))\r\n  datas[,TimeBetas:=betas]\r\n  \r\n  datas[,TravelTime := abs((0-xIntercept)/Tangent)]\r\n  datas = datas[is.finite(Tangent) & is.finite(TravelTime) ]\r\n  \r\n  library(RColorBrewer)\r\n  set =  row.names(subset(brewer.pal.info,colorblind==TRUE & category==\"qual\" & maxcolors>length(BetaTimeSpent)))[1]\r\n  cols =  brewer.pal(length(BetaTimeSpent), set)\r\n  cols = if(length(BetaTimeSpent)<3){cols[c(1,length(cols))]}else{cols}\r\n  datas[,colr:=cols[as.numeric(as.factor(TimeBetas))]]\r\n  # So, what are we doing here?\r\n  d = table(cut(datas$TravelTime,seq(min(datas$TravelTime),max(datas$TravelTime),.5)),\r\n            datas$TimeBetas)\r\n  # For which intervals do we have estimates for all betas?\r\n  d =(apply(d, c(1,2),sign))\r\n  \r\n  c = as.numeric(unlist(str_split(gsub(\"\\\\(|\\\\]\",\"\",                                    names(which(rowSums(d)>=length(BetaTimeSpent))[1])),\",\")))\r\n  c = datas[TravelTime>=c[1] & TravelTime<=c[2]]\r\n  \r\n  # Relationship btw cummulative gain, travel time and time spent in patch\r\n  #par(mfrow=c(1,2))\r\n  layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))\r\n  # gain function\r\n  par(mar=c(0, 4.1, 1, 2.1))\r\n  with(datas,\r\n       plot(c(1:5),c(1:5),xaxt=\"n\",\r\n            xlim = c(-(c$TravelTime[1] +20),max(x)),\r\n            #xlim=c(-max(TravelTime),max(x)),\r\n            ylim=c(0,max(y)),type=\"n\",\r\n            ylab = \"\", xlab =\"TravelTime/TimeSpentInPatch\"))\r\n  mtext(cex=2, side = 2, text = \"Opptak (kcal/tid)\", line =2)\r\n  legend(\"topleft\", \"a)\", cex = 1.5, bty=\"n\")\r\n\r\n  text(-42, 2.47, expression(paste(\"Gain = \", Time^beta, sep = '')), pos = 2,cex=2)\r\n  \r\n  abline(v = 0, lty=\"dashed\")\r\n  \r\n  for(i in 1:nrow(datas)){\r\n    try(\r\n      with(datas,abline(b = Tangent[i], a =xIntercept[i],\r\n                        col= colr[i],lwd =2))\r\n      ,silent=F)\r\n  }\r\n\r\n  # Illustrating how residence time with increasing quality for a given travel time\r\n  par(mar=c(5.1, 4.25, 1, 2.1))\r\n  with(c,\r\n       plot(c(1:5),c(1:5), xlim=c(-max(TravelTime),max(x)+2),ylim=c(0,max(y)),type=\"n\",\r\n            ylab = \"\",\r\n            xlab =\"\",\r\n            xaxt=\"n\"))\r\n  legend(\"topleft\", \"b)\", cex = 1.5, bty=\"n\")\r\n  mtext(cex=2, side = 2, text = \"Opptak (kcal/tid)\", line =2)\r\n  mtext(cex=1.5, side = 1, text = \"Reisetid/Oppholdstid\", line =2.5)\r\n  axis(side = 1, at = round(seq(-max(c$TravelTime),(max(x)+2), by = 10)), labels = abs(round(seq(-max(c$TravelTime),(max(x)+2), by = 10))))\r\n  \r\n  abline(v = 0, lty=\"dashed\")\r\n  for(i in seq_along(BetaTimeSpent)){\r\n    print(i)\r\n    curve(x^BetaTimeSpent[i], from = 0, to = max(x),add = T, col = cols[i],lwd =2)\r\n    with(c[TimeBetas==BetaTimeSpent[i]],\r\n         abline(a = xIntercept, b = Tangent, col = colr,lwd =2))\r\n    with(c[TimeBetas==BetaTimeSpent[i]],\r\n         abline(v = x, col = colr,lwd =2))\r\n  }\r\n  \r\n  #abline(a = 0, b = mean(datas$Tangent),lty=\"dashed\")\r\n  # Relationship between travel time and patch time\r\n  par(mar=c(5.1, 4.4, 1, 2.1))\r\n  with(datas,plot(log(x)~log(TravelTime), type=\"n\",\r\n                  ylab = \"\", xlab=\"\",\r\n                  ylim=c(min(log(x)), max(log(x))), xlim=range(na.omit(log(TravelTime)))))\r\n  for(i in seq_along(BetaTimeSpent)){\r\n    with(datas[TimeBetas==BetaTimeSpent[i]],\r\n         lines(y = log(x), x = log(TravelTime), col = colr,lwd =2))     }\r\n  mtext(cex=2, side = 2, text = \"Oppholdstid (ln)\", line =2)\r\n  mtext(cex=1.5, side = 1, text = \"Reisetid (ln)\", line =2.5)\r\n  legend(\"topleft\", \"c)\", cex = 1.5, bty=\"n\")\r\n  legend(\"bottomright\", legend = BetaTimeSpent, lty = c(1,1), col = cols,cex = 1.5, lwd = 2, bty=\"n\")\r\n\r\n  par(mfrow=c(1,1))\r\n  return(datas)\r\n}\r\nTimes = seq(.5,10,.5)\r\na = MVT(BetaTimeSpent = c(.15,.3), x.values = Times)\r\n\r\n[1] 1\r\n[1] 2\r\n\r\n\r\nFigure 2: Næringsopptak per tidsenhet (f.eks. minutt) minker som regel jo lengre man er i habitatet. I denne grafiske fremstillingen så er tid til venstre for y-aksen reisetid til habitatet, og til høyre er oppholdstid i habitatet. Hvor lenge et individ bør oppholde seg der er da avhenig av hvor lang tid man brukte på å reise til habitatet.\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nMVT_1 = function(Method = \"Standard\", Asymptote = c(.5,1), Rate = c(0.5,1), HalfTime = 4, Intercept = 0, HandlingTime = seq(0,10,.25)){\r\n  # Asymptote = c(.5,1); Rate = c(0.5,1.2); Intercept = 0; HandlingTime = seq(0,10,.25);HalfTime = 4;Method = \"Standard\"\r\n  library(gridExtra);library(data.table)\r\n  \r\n  df = CJ(Asymptote = Asymptote,\r\n          Rate = Rate,\r\n          Intercept = Intercept, HandlingTime = HandlingTime)\r\n  \r\n  # To find the tangents\r\n  # Computes the derivatives\r\n  x = df$HandlingTime\r\n  df$x = x\r\n  if(Method == \"Standard\"){\r\n    GainFunction = deriv(~Asymptote +(Intercept - Asymptote)*exp(-exp(Rate)*x),\"x\")\r\n  }\r\n  if(Method == \"CharnovParker1995\"){\r\n    #Asymptote: Gm = .5 # Proportionate to patch size\r\n    #\r\n    #Rate: \r\n    #     g = .55 # Constant reflecting initial capture rate of prey\r\n    #     c = g/Gm # rate of prey capture\r\n    # Handling Time = t\r\n    # GeneralGainForm = function(Gmax, c, t){  Gmax*(1-exp(-c*t))}\r\n    \r\n    GainFunction = deriv(~Asymptote*(1-exp(-Rate*x)),\"x\")\r\n  }\r\n  if(Method==\"Aastrom_1\"){\r\n    # Asymptote = si = Patch size\r\n    # Rate = k1\r\n    # Handling time = Thi\r\n    # Gain = si*(1-(1/(1+(k1*Thi)))) # Eq. 1 in the paper)\r\n    \r\n    GainFunction = deriv(~Asymptote*(1-(1/(1+Rate*x))),\"x\") # Original\r\n    GainFunction = deriv(~Asymptote -(Asymptote/(1+Rate*x)),\"x\") # Omskrevet\r\n    \r\n  }\r\n  if(Method==\"Aastrom_2\"){\r\n    # Asymptote = si = Patch size\r\n    # Rate = k1\r\n    # Handling time = Thi\r\n    # Gain = si*(1-(1/(1+((k1*Thi)/si)))) # Eq. 2 in the paper)\r\n    \r\n    GainFunction = deriv(~Asymptote*(1-(1/(1+(Rate*x/Asymptote)))),\"x\") # original fra paper\r\n    GainFunction = deriv(~Asymptote - (Asymptote^2)/(Asymptote+Rate*x),\"x\") # omskrevet\r\n    \r\n  }\r\n  if(Method==\"LogLog\"){\r\n    if(any(Rate)>1){\r\n      print(\"Stop. Can not handle exponentially increasing gain curves, as this would imply infinite residence time.\")\r\n    }\r\n    GainFunction = deriv(expr = ~exp(Intercept)*x^Rate*Asymptote,\"x\")\r\n  }\r\n  if(Method==\"Sigmoid\"){\r\n    # Gompertz\r\n    # Asymptote = 1 # asympmtote, opprinnelig a\r\n    # b: half-way, x displacement\r\n    # Rate: c\r\n    #HalfWay = mean(HandlingTime)\r\n    # print(\"Set halftime of the function to be equal to mean of handling times under consideration\")\r\n    # Logistic function\r\n    # Asymptote/(1 + exp(-Rate*(x-HalfTime)))\r\n    \r\n    GainFunction = deriv(~Asymptote/(1 + exp(-Rate*(x-HalfTime))),\"x\")\r\n    \r\n  }\r\n  \r\n  # The y - values along the x-values\r\n  bsG = eval(GainFunction, envir = df)\r\n  df$Gain = bsG[seq_along(x)]\r\n  \r\n  # The derivatives\r\n  df$TangentG = c(attr(bsG,\"grad\"))\r\n  # And where the tangent line crosses the x-axis\r\n  df$xInterceptG = with(df, Gain -TangentG*HandlingTime)\r\n  # Gives us then enough information to find the optimal travel time\r\n  df$TravelTimeG = with(df, abs((0-xInterceptG)/TangentG))\r\n  # Second derivative\r\n  df[,SecDer:= c(NA,diff(TangentG)), c(\"Rate\", \"Asymptote\")]\r\n  \r\n  \r\n  \r\n  \r\n  ### PLOTS\r\n  df = data.table(df)\r\n  df[,Rate := as.factor(Rate)]\r\n  df[,Asymptote := as.factor(Asymptote)]\r\n  df[,Intercept := as.factor(Intercept)]\r\n  \r\n  lsize =  2\r\n  library(ggpubr)\r\n  library(cowplot)\r\n  \r\n  p1 = ggplot(data = df, aes(x = HandlingTime , y = Gain, \r\n                             col = Rate, \r\n                             linetype = Asymptote, \r\n                             group = interaction(Rate, Asymptote, Intercept))) +\r\n    xlab(\"Oppholdstid\") + ylab(\"Opptak\") +\r\n    geom_line(size = lsize)+theme_classic() + theme(text = element_text(size = 20)) \r\n  # \r\n  # p2 = ggplot(data = df, aes(x = HandlingTime , y = TangentG, col = interaction(Rate, Intercept), linetype = Asymptote, group = interaction(Rate, Asymptote, Intercept)))+\r\n  #   xlab(\"Oppholdstid\") + ylab(\"Funksjonell respons\") +\r\n  #   geom_line(size = lsize)+theme_classic() + theme(text = element_text(size = 20)) \r\n  \r\n  \r\n  p3 = ggplot(data = df, aes(x = TravelTimeG , y = HandlingTime, \r\n                             col = Rate,\r\n                             linetype = Asymptote, \r\n                             group = interaction(Rate, Asymptote, Intercept))) + ylab(\"Oppholdstid\") + xlab(\"Reisetid\")+\r\n    geom_line(size = lsize)+theme_classic() + theme(text = element_text(size = 20)) \r\n  \r\n  p4 = ggplot(data = df, aes(x = log(TravelTimeG) , y = log(HandlingTime), \r\n                             col = Rate, \r\n                             linetype = Asymptote, \r\n                             group = interaction(Rate, Asymptote, Intercept)))  +\r\n    ylab(\"Oppholdstid (log)\") + xlab(\"Reisetid (log)\")+\r\n    geom_line(size = lsize)+theme_classic() + theme(text = element_text(size = 20)) \r\n  \r\n  print(ggarrange(p1, p3, p4, ncol=3, nrow=1, common.legend = TRUE, legend=\"bottom\", labels = \"auto\"))\r\n  return(as.data.table(df))\r\n\r\n}\r\n\r\n\r\nUtledninger\r\nGenerell løsning\r\nMan har for oppholdstid \\(t*\\) så vil funksjonen \\(G(t)\\) ha stigningstall (tangent) lik \\(\\delta G/\\delta t\\)\r\nPunktet hvor tangenten \\(\\delta G/\\delta t\\) skjærer i x-aksen er reisetid \\(T_s\\).\r\nTangenten er jo en rett linje som kan beskrives med stigningstll \\(b\\) og skjæringspunkt \\(a\\), slik at \\(T_s = -a/b\\). Hvor \\(a = G(t = t*) - \\delta G/\\delta t\\), og \\(b = \\delta G/\\delta t\\).\r\nGenerell løsning. \\(\\delta t^*\\) vil være kortform for den \\(\\delta G/\\delta t\\) ved punkt \\(t^*\\). \\[\r\nT_s = -a/b\r\n\\] \\[\r\nT_s = -(\\frac{G(t = t^*) - \\delta G/\\delta t}{\\delta t^*})\r\n\\] \\[\r\n-T_s = t^* - \\frac{G(t = t^*)}{\\delta t^*}\r\n\\] \\[\r\n-T_s = -t^* + \\frac{G(t = t^*)}{\\delta t^*} \r\n\\] \\[\r\nT_s = t^* - \\frac{G(t = t^*)}{\\delta t^*}\r\n\\]\r\nDette vil så kunne løses for gitte nyttefunksjoner \\(G(t)\\).\r\nLog-Log\r\nEn annen måte å skrive det vil være å se på det som et log-log-forhold.\r\nAntall enheter inntak kan beskrives som Poisson-prosess. Poisson kan brukes til modellere proportional hazard-modeller1, som er brukt til å modellere hvor lenge individ skal være i et område.2 Ved å bruke log-tid (\\(\\beta_{log-tid}\\)) som forklaringsvariabel på opptak kan responsen tolkes som en rate. I MVT antar en avtagende utbytte, slik at \\(\\beta_{log-tid}<1\\). - https://ntnuopen.ntnu.no/ntnu-xmlui/bitstream/handle/11250/2977833/CarlsenRecoveryAnimBehav2021hybrid.pdf?sequence=1\r\nI studier som går på habitatbruk legger man ofte til areal tilgjengelig habitat som offset for å se på hvordan bruken avviker fra tilgjengelighet. Ved å legge det til som en offset så antar man at opptak skal øke proporsjonalt med areal altså habitatvalg. Tilsvarende kan man også gjøre her.\r\n\\(log(Opptak) = \\beta_{Rate} * log(Areal\\)\r\nVed å legge til \\(log(Areal)\\) vil det endelige uttrykket være \\(Opptak = Areal^{\\beta_{areal}}*Tid^{\\beta_{tid}}\\).\r\nOg hvis areal er lagt til som en offset vil \\(\\beta_{areal}=1\\), slik at\r\n\\(Opptak = Areal*Tid^{\\beta_{tid}}\\)\r\nFor log-log-funksjonen vi så over hvor \\(log(G(t)) = \\beta log(t)\\). \\[\r\nG(t) = t^\\beta\r\n\\] og \\[\r\n\\frac{\\delta G}{\\delta t} = \\beta t^{\\beta-1}\r\n\\] Vi setter dette inn i det generelle løsningen over.\r\n\\[\r\nT_s = t^*- \\frac{t^{*\\beta}}{\\beta t^{*\\beta - 1}}\r\n\\] Som forenkles til \\[\r\nT_s = t^*- \\frac{t^{*}}{\\beta}\r\n\\]\r\n\\[\r\nT_s = t^* (1 - \\frac{1}{\\beta})\r\n\\] \\[\r\n\\frac{T_s}{1-\\frac{1}{\\beta}} = t^*\r\n\\]\r\nSimuleringer\r\nLévy walk blir av noen ansett som en egenskap som oppstår som et resultat av omstendighetene (‘emergent property’) og ikke en egenskap i seg selv. Men er vist i flere som regel som en strategi som er optimal, uavhengig av omstendighetene:\r\nsom denne\r\ndenne\r\nog denne\r\n\r\nNedenfor ser vi også såvidt på relasjonene mellom oppholdstid\r\n\r\n\r\nShow code\r\n\r\nlibrary(data.table)\r\nlibrary(ggplot2)\r\nlibrary(spatstat)\r\nlibrary(doParallel)\r\n\r\nno_cores <- detectCores() - 1  \r\ncl <- makeCluster(no_cores)  \r\nregisterDoParallel(cl)  \r\n\r\nBetas = seq(.3,.9, length.out = 5)\r\ntmax = 700\r\nBetasRun = list()\r\n#BetaRuns = lapply(c(.3,.75,.9), function(d){#lapply-versjon\r\n# foreach(dd = seq_along(Betas), .packages = (.packages())) %dopar% {\r\n#   d = Betas[dd]\r\n#   print(d)\r\n#   \r\n#   DoPlot = F\r\n#   nRuns = 50\r\n#   if(!file.exists(paste0(\"Runs_\",d,\".rds\"))){\r\n#     Runs = rbindlist(lapply(nRuns:1, function(run){\r\n#       print(run)\r\n#       set.seed(run)\r\n#       \r\n#       # Deviation from optimal\r\n#       deviation =  sample(seq(-10,10,5),1)\r\n#       #deviation =  seq(-10,10,5)\r\n#       #Run time and population\r\n#       tmax = tmax\r\n#       nInd = 1\r\n#       \r\n#       ## Make grid\r\n#       maxD = 2500\r\n#       densP = 0.6 # tetthet av mat\r\n#       nP = floor(maxD*(densP)) # antall matlokasjoner\r\n#       Y = X = seq(0,maxD, by = 1)\r\n#       \r\n#       # Box size\r\n#       sizeP = 20\r\n#       Radii = rep(sizeP, nP)\r\n#       \r\n#       Grid = TRUE\r\n#       if(Grid==TRUE){\r\n#         uns = seq(0,maxD, Radii[1])+Radii[1]/2\r\n#         SampleGrid = expand.grid(uns,uns)\r\n#         plotsC = SampleGrid[sample(1:nrow(SampleGrid), nP),]\r\n#         \r\n#         plots = lapply(1:nrow(plotsC), function(x){\r\n#           bbox = rbind(x = c(plotsC[x,1]-Radii[1]/2, plotsC[x,1]+Radii[1]/2),\r\n#                        y = c(plotsC[x,2]-Radii[1]/2, plotsC[x,2]+Radii[1]/2))\r\n#           #rect(plots[[x]][1,1], plots[[x]][2,1], plots[[x]][1,2], plots[[x]][2,2])\r\n#           bbox\r\n#         })\r\n#       }else{\r\n#         # Create initial kernels\r\n#         cP = 1\r\n#         plotsC = matrix(round(runif(1*2, \r\n#                                     min = 0, max = maxD)),\r\n#                         ncol = 2)\r\n#         plots = list()\r\n#         plots[[cP]]<-rbind(x = c(plotsC[cP,1]-Radii[cP],\r\n#                                  plotsC[cP,1]+Radii[cP]),\r\n#                            y = c(plotsC[cP,2]-Radii[cP],\r\n#                                  plotsC[cP,2]+Radii[cP]))\r\n#         while(cP<nP){\r\n#           # Generer en ny en\r\n#           t1 = matrix(round(runif(1*2, min = 0, max = maxD)), ncol = 2)\r\n#           # Er den nye for nærme noen eksisterende?\r\n#           a = as.matrix(dist(rbind(t1,plotsC)))[-1,1]\r\n#           # Hvis nei, bygg boksen\r\n#           bnd = sqrt(Radii[1]^2 + Radii[1]^2)*2\r\n#           if(!any(a<bnd)){\r\n#             t2 = rbind(x = c(t1[1,1]-Radii[1], t1[1,1]+Radii[1]),\r\n#                        y = c(t1[1,2]-Radii[1], t1[1,2]+Radii[1]))\r\n#             \r\n#             cP <- cP + 1\r\n#             plots[[cP]]<-t2\r\n#             plotsC <-rbind(plotsC,t1)\r\n#           }\r\n#         }\r\n#       }\r\n#       \r\n#       if(DoPlot){\r\n#         plot(1~1, type = \"n\", \r\n#              xlim = c(-20,maxD+20), ylim = c(-20, maxD+20))\r\n#         \r\n#         lapply(seq_along(plots), function(x){\r\n#           rect(plots[[x]][1,1], \r\n#                plots[[x]][2,1], \r\n#                plots[[x]][1,2], \r\n#                plots[[x]][2,2])\r\n#         })\r\n#       }\r\n#       \r\n#       ####\r\n#       # Exponent of the gain curve\r\n#       Betas = d#.75 #runif(nInd, min = 0.1, max = .90)\r\n#       \r\n#       Stay = rep(0, nInd)\r\n#       Arrival = rep(0, nInd)\r\n#       Residence = rep(0, nInd)\r\n#       \r\n#       Gains = rep(0, nInd)\r\n#       Gained = Gains\r\n#       \r\n#       # generate random start locations for the individuals\r\n#       set.seed(run)\r\n#       pos = t(sapply(1:nInd, function(x) round(runif(2, min = maxD*0.45, max = maxD*.55))))\r\n#       \r\n#       #pos = matrix(c(30,40), ncol = 2)\r\n#       DF = array(0,dim = c(tmax, 8, nInd),\r\n#                  dimnames = list(c(1:tmax),\r\n#                                  c(\"State\", \"Box\", \"ResidenceTime\", \"Traveltime\",\"Gain\",\"PosX\", \"PosY\", \"Dist\"),\r\n#                                  c(1:nInd)))\r\n#       DF[1,\"Traveltime\",]<-0# round(runif(nInd, min = 4, max = 10))\r\n#       class(DF[,\"Traveltime\",])<-\"numeric\"\r\n#       \r\n#       # Merk den gjennomsnittlige steg lengden er kortere enn lengden/bredden av en foraging box\r\n#       Moves = function(Mode = \"Levy\", alpha = 2, n = 1){\r\n#         t(sapply(1:n, function(x){if(Mode == \"Levy\"){\r\n#           dist = 0\r\n#           while(dist==0 | dist>500){# For å forhindre kjempelange steg\r\n#             dist =   runif(1)^(1/(1 - alpha)) # Alternativ https://rdrr.io/cran/adehabitatLT/src/R/simm.levy.r\r\n#           }\r\n#           \r\n#           angle = runif(1)*2*pi\r\n#           \r\n#           dx = dist * sin(angle)\r\n#           dy = dist * cos(angle)\r\n#         }else{\r\n#           dx = rnorm(n = 1, mean = 0, sd = 5)\r\n#           dy = rnorm(n = 1, mean = 0, sd = 5)\r\n#         }\r\n#           c(dx,dy)}))\r\n#       }\r\n#       \r\n#       t = 1\r\n#       while(t < tmax){\r\n#         \r\n#         inBox = apply(pos, 1, function(x){\r\n#           sapply(plots, function(P){ \r\n#             x[1] %between% P[1,] & # x-coordinate\r\n#               x[2] %between% P[2,]# y-coordinate\r\n#           }) \r\n#         }, simplify = T)\r\n#         \r\n#         # Evaluate whether individuals are in boxes or not\r\n#         for(cols in 1:ncol(inBox)){\r\n#           DF[t,c(\"PosX\", \"PosY\"),cols]<-pos[cols,]\r\n#           # in a box, and should stay there longer\r\n#           # if(any(inBox[,cols])){print(\"In box\")}\r\n#           if(any(inBox[,cols]) & Arrival[cols]==0){\r\n#             # First time landed in plot\r\n#             Arrival[cols] <- t\r\n#             # gets no food on arrival\r\n#             # How long should the individual remain in the box\r\n#             RT = round(as.numeric(DF[t,\"Traveltime\",cols])/(1 + (1/Betas[cols])))\r\n#             \r\n#             RT = RT + (RT/100*deviation)\r\n#             \r\n#             DF[t,\"ResidenceTime\",cols] <- RT\r\n#             Stay[cols] <- t+as.numeric(DF[t,\"ResidenceTime\",cols])\r\n#             \r\n#             DF[t,\"State\",cols]<-\"Arrival\"\r\n#             # Which box is individual in?\r\n#             DF[t,\"Box\",cols]<-min(which(inBox[,cols]))\r\n#           }\r\n#           \r\n#           if(any(inBox[,cols]) & Arrival[cols]<t){ \r\n#             # Is in plot from previous round, and we have passed the arrival time\r\n#             \r\n#             # Which box is individual in?\r\n#             DF[t,\"Box\",cols]<-min(which(inBox[,cols]))\r\n#             \r\n#             # How long have the individual been in the plot\r\n#             ResidenceTime = as.numeric(DF[(t-1),\"ResidenceTime\",cols])\r\n#             # How much to gain?\r\n#             Gains[cols] <- Gains[cols]  + ((ResidenceTime^Betas[cols])-((ResidenceTime-1)^Betas[cols]))\r\n#             #print(Gains[cols])\r\n#             DF[t,\"ResidenceTime\",cols]<-as.numeric(DF[(t-1),\"ResidenceTime\",cols])-1\r\n#             DF[t,\"State\",cols]<-\"Forage\"\r\n#             \r\n#             # Reset travel time since you have stayed in a box\r\n#             DF[t,\"Traveltime\",cols]<-0\r\n#           }\r\n#           \r\n#           \r\n#           # Move individuals\r\n#           for(cols in 1:ncol(inBox)){\r\n#             DF[t,\"Gain\", cols]<-(Gains[cols]) \r\n#             if(DoPlot){\r\n#               # plot positions\r\n#               points(pos[cols,2]~pos[cols,1],\r\n#                      cex = 2, \r\n#                      pch = ifelse(DF[(t-1),\"State\",cols]==\"Movement\",15,17),\r\n#                      \r\n#                      col = ifelse(any(inBox[,cols]), \"green\", \"red\"))\r\n#             }\r\n#             \r\n#             # Only move those who are outside of box, or spent too much time in box\r\n#             if(!any(inBox[,cols]) | DF[t,\"ResidenceTime\",cols]==0){\r\n#               \r\n#               DF[t,\"State\",cols]<-\"Movement\"\r\n#               # Reset arrival as we have started to move again\r\n#               Arrival[cols] <- 0\r\n#               \r\n#               # If in a box, move it to the edge to ensure movement away from box\r\n#               if(any(inBox[,cols])){\r\n#                 \r\n#                 \r\n#                 tmp = plots[[min(which(inBox[,cols]))]]\r\n#                 pos[cols,] <-round(c(runif(1,tmp[1,1],tmp[1,2]),\r\n#                                      runif(1,tmp[2,1],tmp[2,2])))\r\n#                 \r\n#                 # Include a while-loop, to run as long as the individual remains inside. this way to ensure movement away from the patch\r\n#                 while(any(sapply(plots, function(P){ \r\n#                   pos[cols,][1] %between% P[1,] & # x-coordinate\r\n#                     pos[cols,][2] %between% P[2,]# y-coordinate\r\n#                 }))){\r\n#                   dist = Moves()\r\n#                   pos[cols,] = round(pos[cols,] + dist)\r\n#                 }\r\n#               }else{\r\n#                 dist = Moves()\r\n#                 pos[cols,] = round(pos[cols,] + dist)\r\n#               }\r\n#               DF[t,\"Dist\",cols]<-sqrt(sum(dist^2))\r\n#               \r\n#               # Increase travel time for those who are not in boxes\r\n#               DF[t+1,\"Traveltime\",cols]<-as.numeric(DF[t,\"Traveltime\",cols])+1\r\n#             }\r\n#           }\r\n#           \r\n#           # If moving outside the grid, relocate to new random place\r\n#           for(cols in 1:nInd){\r\n#             if(any(pos[cols,]>maxD) | any(pos[cols,]<0)){\r\n#               pos[cols,]<-runif(2, min = maxD*0, max = maxD*1)\r\n#             }\r\n#           }\r\n#           #print(DF[t,\"Gain\", ])\r\n#           #Gained = rbind(Gained, Gains)\r\n#           t = t + 1\r\n#         }\r\n#         \r\n#       }\r\n#       DT = data.table(DF[,,1])\r\n#       DT[,Deviation:=deviation]\r\n#       \r\n#       DT[,Run:=run]\r\n#       DT[,Beta := Betas[1]]\r\n#       ddd = dist(plotsC)\r\n# \r\n#       DT[,DistanceBtwPlots_median:=median(ddd)\r\n#          ][,DistanceBtwPlots_var:=var(ddd)\r\n#            ][,DistanceBtwPlots_clustering:=mean(nndist(ddd, k = 1))\r\n#            ]\r\n#       gc() # Clear memory\r\n#       DT\r\n#       #with(DT[State==\"Arrival\"], plot(ResidenceTime~Traveltime))\r\n#       #list(Gains = Gains, Deviation = deviation, Decisions = Decisions)\r\n#     }))\r\n#     gc() # Clear memory\r\n#     saveRDS(Runs, file = paste0(\"Runs_\",d,\".rds\"))\r\n#   } else {\r\n#     Runs = readRDS(file = paste0(\"Runs_\",d,\".rds\"))\r\n#   }\r\n#   \r\n#   BetasRun[[dd]]<<-Runs\r\n#   Runs\r\n# }\r\n# stopCluster(cl)\r\nBetasRun = lapply(Betas, function(d){\r\n  Runs = readRDS(file = paste0(\"Runs_\",d,\".rds\"))\r\n  Runs\r\n})\r\n#}) #lapply-versjon\r\n\r\n#BetaRuns2 = rbindlist(BetaRuns) # for lapply v\r\nBetaRuns2 = rbindlist(BetasRun)\r\n\r\nBetaRuns2[,Time:=1:.N, c(\"Run\", \"Beta\")]\r\n\r\nBetaRuns2[,Traveltime:=as.numeric(Traveltime)]\r\n  BetaRuns2[,ResidenceTime:=as.numeric(ResidenceTime)]\r\nBetaRuns2[,Gain := as.numeric(Gain)]\r\nBetaRuns2[,Beta := factor(Beta)]\r\nBetaRuns2[,Deviation := factor(Deviation)]\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[State==\"Arrival\"], mapping = aes(col = factor(Beta)))+\r\n  geom_point(mapping = aes(x = Traveltime, y = ResidenceTime))+\r\n  geom_line(mapping = aes(x = Traveltime, y = ResidenceTime))+\r\n  ylab(\"Oppholdstid\")+\r\n  xlab(\"Reisetid\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[,.SD[which.max(Gain)], c(\"Beta\", \"Deviation\", \"Run\")],\r\n       mapping = aes(col = factor(Beta)))+\r\n  geom_boxplot(mapping = aes(x = factor(Deviation), y = Gain))+\r\n  facet_wrap(~Beta)+\r\n  ylab(\"Nytte\")+\r\n  xlab(\"Avvik fra optimum oppholdstid\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[,.SD[which.max(Gain)], c(\"Beta\", \"Deviation\", \"Run\")],\r\n       mapping = aes(col = factor(Beta)))+\r\n  stat_smooth(mapping = aes(x = DistanceBtwPlots_median, \r\n                            y = Gain), method = \"lm\")+\r\n  ylab(\"Oppholdstid\")+\r\n  xlab(\"Avstand mellom habitat (median)\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[,.SD[which.max(Gain)], c(\"Beta\", \"Deviation\", \"Run\")],\r\n       mapping = aes(col = factor(Beta)))+\r\n  stat_smooth(mapping = aes(x = DistanceBtwPlots_var, \r\n                          y = Gain), method = \"lm\")+\r\n  ylab(\"Nytte\")+\r\n  xlab(\"Variasjon i spredning mellom habitat\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[,.SD[which.max(Gain)], c(\"Beta\", \"Deviation\", \"Run\")],\r\n       mapping = aes(col = factor(Beta)))+\r\n  stat_smooth(mapping = aes(x = DistanceBtwPlots_clustering, \r\n                            y = Gain), method = \"lm\")+\r\n  ylab(\"Nytte\")+\r\n  xlab(\"Avstand til nærmeste nabo (gj.snitt)\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\nggplot(data = BetaRuns2[,.SD[which.max(Gain)], c(\"Beta\", \"Deviation\", \"Run\")],\r\n       mapping = aes(col = factor(Beta)))+\r\n  stat_smooth(mapping = aes(x = DistanceBtwPlots_clustering, \r\n                            y = ResidenceTime), method = \"lm\")+\r\n  ylab(\"Oppholdstid\")+\r\n  xlab(\"Avstand til nærmeste nabo (gj.snitt)\")+\r\n  labs(col = \"Nyttefunksjon\")\r\n\r\n\r\nShow code\r\n\r\ndf = BetaRuns2[,.(Gain=max(Gain,na.rm = T), ResidenceTime = mean(ResidenceTime)),\r\n               c(\"Beta\", \"Deviation\", \"Run\", \"DistanceBtwPlots_clustering\",\"DistanceBtwPlots_var\",\"DistanceBtwPlots_median\")]\r\nlibrary(lme4);library(MuMIn)\r\ndf[,CV:=DistanceBtwPlots_var/DistanceBtwPlots_median]\r\n# summary(df)\r\n# dredge(lmer(log(Gain)~CV*Beta + \r\n#               ResidenceTime*Beta + \r\n#               DistanceBtwPlots_clustering*Beta + \r\n#               log(DistanceBtwPlots_median)*Beta + \r\n#               Deviation + \r\n#               (1|Run), data = df, na.action = na.fail, REML = F)\r\n#        #, fixed = c(\"Deviation\")\r\n#        )\r\n\r\n\r\nSigmoide nyttefunksjoner\r\nHvis et individ kommer inn i habitatet og bruker litt tid på å orientere seg om hva som er den mest nyttige maten før den spesialiserer seg inn på denne. En kan da ende opp med en sigmoid nyttefunksjon (Searle et al. (2005), Spalinger and Hobbs (1992) likning 30).\r\n\\(G(t) = \\frac{\\alpha\\cdot t^2\\cdot M}{\\alpha\\cdot t^2 + M}\\)\r\n\r\n\r\nShow code\r\n\r\nALPHA = .002\r\nBioMass = 0.382\r\n\r\n\r\nggplot() +\r\n  xlim(0, 40)+\r\n  geom_function(fun = function(x) \r\n    (ALPHA*BioMass*x^2)/(BioMass + ALPHA*x^2)\r\n  )+\r\n  theme_cowplot()+\r\n  theme(axis.text=element_blank(),axis.title=element_blank(),legend.position = \"none\")\r\n\r\n\r\n\r\nFigure 3: Sigmoide nyttefunksjon.\r\n\r\n\r\n\r\nDen deriverte av nyttefunksjonen i \\(t^*\\) er lik langtidsnytten. I MVT optimum \\(t^*\\), som gitt over, så er nyttefunksjonen sin andrederiverte < 0. For nyttefunksjoner som ikke er konkav (-opp) så vil ikke den generelle påstanden over om at å forbedre kvaliteten på habitatet øke oppholdstiden gjelde (Calcagno et al. (2014), fantastisk artikkel som man aldri kan få nok av). Da vil oppholdstiden bli kortere og individ vil bruke mer tid på å bevege seg mellom habitat.\r\nCalcagno-gjennomgang (kladd)\r\nI heterogene miljø er snittet angitt som \\(<y_j>\\). \\(s\\) ulike miljø med frekvens \\(p_i\\)\r\nLikning 11 fra Calcagno 2013/2014\r\n\\[\\frac{dt^*}{dx} = -E_n^*(\\frac{\\delta}{\\delta x}ln\\frac{\\delta F(x,t^*)}{\\delta t} - \\frac{\\delta ln E_n^*}{\\delta x})(\\frac{\\delta^2F(x,t^*)}{\\delta t^2})^{-1}\\]\r\nLikning 8\r\n\\[\\frac{\\delta\\space ln E^*_n}{\\delta x_i} = \\frac{\\delta ln <F_j (x_j ,t^*_j>}\\]\r\n\r\n\r\nShow code\r\n\r\n#h(n) # Opptak per ressursnivå n\r\n#h(n) = n^theta\r\nggplot() +\r\n  xlim(0, 3)+\r\n  geom_function(fun = function(x) \r\n    x^.5, col = \"green\")+\r\n  geom_function(fun = function(x) \r\n    x^1, col = \"blue\")+\r\n  geom_function(fun = function(x) \r\n    x^2, col = \"red\")+\r\n  theme_cowplot()+\r\n  theme(axis.text=element_blank(),legend.position = \"none\")+\r\n  xlab(\"Ressursnivå (n)\")+ylab(\"Ressursopptak (h) per tidsenhet\")\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\n# Time t\r\n# eat h(t)\r\n# deplete resource by n = -h(n)/S\r\nForage = function(n, theta = 2/3, S = .01){\r\n  S*(n^theta)\r\n}\r\n\r\nDeplete = function(n0, theta = 2/3, S = .01){\r\n  n0-S*(n0^theta)\r\n}\r\n\r\nGain = function(time, Resource = 50, theta = 3/2, PatchCost = .1, TravelCost = .4, Travel = 1,...){\r\n  Gains = 0\r\n  Gains = Gains - TravelCost*Travel\r\n  for(i in 1:time){\r\n      if(Resource>0 & !is.nan(Resource)){\r\n      Gains = Gains + Forage(n = Resource, theta = theta,...)\r\n      Resource = Resource = Deplete(n0 = Resource, theta = theta,...)\r\n    }\r\n    Gains = Gains-PatchCost\r\n  }\r\n  c(Gain = Gains, Resource = Resource, PatchCost = PatchCost*time)\r\n}\r\n\r\n\r\nlibrary(data.table);library(ggplot2);library(cowplot)\r\ntmp = CJ(Time=1:30, \r\n         Resources = c(50),\r\n         Thets = c(.8,1,1.2))\r\ntmp[,idx:=1:.N]\r\ntmp[,Gains:=Gain(time = Time, PatchCost = .001, Travel = 0,\r\n                 Resource = Resources, theta = Thets)[1], by = idx]\r\n\r\nggplot(data = tmp, aes(x = Time, y = Gains, col = factor(Thets), shape = factor(Resources))) +\r\n  xlim(0, 10)+\r\n  geom_line()+\r\n  theme_cowplot()\r\n\r\n\r\n\r\nUtledninger for andre nyttefunksjoner\r\nSih 1980\r\nNå tar vi utgangspunkt i nyttefunksjonen fra likning 2 Sih (1980).\r\n\\[G(t) = \\frac{G_{max}t}{d + t}\\] I denne studien har vi byttet ut \\(c\\) med \\(d\\), da \\(d\\) er invers av hvordan vi har tolket raten tidligere.\r\n\\[\\frac{\\delta}{\\delta t} = \\frac{dG}{(d+t)^2}\\]\r\n\\[T_s = t - \\frac{\\frac{G_{max}t}{d + t}}{\\frac{dG}{(d+t)^2}}\\]\r\n\\[T_s = t - \\frac{t(d+t)}{d}\\] \\[ t = \\sqrt{dT_s}\\] \\[ T_s = \\frac{t^2}{d}\\]\r\nSih 1980 alternativ\r\n\\[G(t) = \\frac{G_{max}t}{dG_{max} + t}\\] \\[\\frac{\\delta}{\\delta t} = \\frac{dG^2}{(dG+t)^2}\\] \\[T_s = t - \\frac{t(dG_{max}+t)}{G_{max}d}\\]\r\nÅström mfl 1990 likn. 1\r\nNyttefunksjoner kan utformes på svært mange måter, men i praksis så ser man at de fleste er avtagende (dvs. deakkselererende eller konveks).\r\nI praksis vil man ofte være interessert i hva skjer om en bedrer habitatet for arten. Noen slik nytte-funksjoner bedrer habitatkvaliteten ved å øke asymptoten (se likning #eq:EQ1). Dette kan sammenlignes med å f.eks. doble mengden mat i habitatet. Men da har man sett at dette, i teorien, ikke har påvirket hvor lenge et individ bør oppholde seg der (Charnov and Parker 1995; Ranta et al. 1995; Livoreil and Giraldeau 1997).\r\n\\[\r\nF(t) = Asymptote - \\frac{Asymptote}{1 + Rate\\cdot t} \\tag{1}\r\n\\]\r\n\r\n\r\nShow code\r\n\r\na = MVT_1(HandlingTime = seq(0,3,.05), Rate = c(0.75,.9), Intercept = c(0,1), HalfTime = 1.5, Method = \"Aastrom_1\")\r\n\r\n\r\n\r\n\\[\r\nF(t) = Asymptote - \\frac{Asymptote^2}{Asymptote + Rate\\cdot t} \\tag{2}\r\n\\]\r\nForskjeller mellom disse er at likning (1) antar at prosent opptak er uavhengig av størrelsen på habitatet. Det vil si at en elg vil spise opp 20 % av en treklyngen på 10 minutt, uavhengig om treklyngen består av 10 eller 40 trær. Og det henger jo nøvendigvis ikke helt på greip. I likning (2) vil håndteringstiden øke med habitatstørrelsen, dvs. kurven blir flatere, og for de 10 minuttene så vil elgen ha spist en mindre andel av en stor klynge enn en liten klynge.\r\nVidere vil opptaket i starten være variere habitatstørrelsen i (1), men ikke i (2).\r\n\r\n\r\nShow code\r\n\r\na = MVT_1(HandlingTime = seq(0,3,.05), Rate = c(0.75,.9), Intercept = c(0,1), HalfTime = 1.5, Method = \"Aastrom_2\")\r\n\r\n\r\n\r\nMed utgangspunkt i nyttefunksjonene presentert som likning 1 i Astrom, Lundberg, and Danell (1990).\r\nFor liking 1 fra Åström mfl. 1990\r\n\\[ G(t) = S_i(1 - \\frac{1}{1 + kt}) \\]\r\nog \\[ \\frac{\\delta G}{\\delta t} = \\frac{ks}{(1 + kt)^2}\\]\r\nVi setter dette inn i det generelle løsningen over. \\[ T_s = t^*- \\frac{s(1-\\frac{1}{1 + kt})}{\\frac{ks}{(1 + kt)^2}}\\]\r\n\\[ T_s = t^*- \\frac{((1-kt)^2)(s - \\frac{s}{1 - kt})}{ks} \\] \\[ T_s = t^* - t^*(kt^*-1) \\] \\[ T_s = t^* - kt^{*2} - t \\]\r\n\\[ T_s = kt^{*2} \\] \\[ \\sqrt{\\frac{T_s}{k}} = t^* \\]\r\nÅström mfl 1990 likn. 2\r\nMed utgangspunkt i nyttefunksjonene presentert som likning 2 i Astrom, Lundberg, and Danell (1990).\r\nFor likning 2 fra Åström mfl. 1990\r\n\\[ \r\nG(t) = S_i(1 - \\frac{1}{1 + \\frac{kt}{S_i}}) = S - \\frac{S{_i}^2 }{S_i + kt}\r\n\\] og \\[ \r\n\\frac{\\delta G}{\\delta t} = \\frac{kS_{i}^2}{(kt + S_i)^2}\r\n\\]\r\nVi setter dette inn i det generelle løsningen over.\r\n\\[\r\nT_s = t - \\frac{S - \\frac{S{_i}^2 }{S_i + kt}}{\\frac{kS_{i}^2}{(kt + S_i)^2}}\r\n\\] Og forenkler denne til\r\n\\[\r\nT_s = \\frac{(-1)kt^2}{S}\r\n\\]\r\nSom vi løser for \\(t\\)\r\n\\[-\\frac{S_{i}T_{s}}{k} = t^2 \\]\r\nAlternativt, ved å gå tilbake til den generelleløsningen så kan \\(b\\) også skrives som \\(b = G(t)/[t^* + T_s]\\).\r\nHvis man bruker den, så vil \\(T_s = T_s + t\\)\r\n\\(t = T_s/2\\)\r\n\r\n\r\n\r\nAstrom, Marten, Per Lundberg, and Kjell Danell. 1990. “Partial Prey Consumption by Browsers: Trees as Patches.” The Journal of Animal Ecology, 287–300.\r\n\r\n\r\nCalcagno, Vincent, Frédéric Grognard, Frédéric M Hamelin, Eric Wajnberg, and Ludovic Mailleret. 2014. “The Functional Response Predicts the Effect of Resource Distribution on the Optimal Movement Rate of Consumers.” Ecology Letters 17 (12): 1570–79.\r\n\r\n\r\nSearle, Kate R, Thea Vandervelde, N Thompson Hobbs, and Lisa A Shipley. 2005. “Gain Functions for Large Herbivores: Tests of Alternative Models.” Journal of Animal Ecology 74 (1): 181–89.\r\n\r\n\r\nSih, Andrew. 1980. “Optimal Foraging: Partial Consumption of Prey.” The American Naturalist 116 (2): 281–90.\r\n\r\n\r\nSpalinger, Donald E, and N Thompson Hobbs. 1992. “Mechanisms of Foraging in Mammalian Herbivores: New Models of Functional Response.” The American Naturalist 140 (2): 325–48.\r\n\r\n\r\nMcCullagh, Peter, and John A. Nelder. Generalized linear models. Routledge, 2000.↩︎\r\nWajnberg, Fauvergue and Pons. “Patch leaving decision rules and the Marginal Value Theorem: an experimental analysis and a simulation model.” Behavioral Ecology 11.6 (2000): 577-586↩︎\r\n",
    "preview": "posts/MVT/MVT_files/figure-html5/FIG0-1.png",
    "last_modified": "2023-12-10T13:12:44+01:00",
    "input_file": "MVT.knit.md"
  },
  {
    "path": "posts/2022-10-01-metapopulasjoner-del-2/",
    "title": "Metapopulasjoner - del 2",
    "description": "Vi er alle sammen individer i lag.",
    "author": [
      {
        "name": "Endre Grüner Ofstad",
        "url": {}
      }
    ],
    "date": "2023-08-07",
    "categories": [
      "Økologi",
      "Økosystem",
      "Arter",
      "Dragehode",
      "Dragehodeglansbille",
      "Verneområde"
    ],
    "contents": "\r\n\r\nContents\r\nHvilke områder kan gjøre nettverket sterkere?\r\nNye verneområder\r\n\r\nHvilke områder er viktige?\r\nDragehode og dragehodeglansbille\r\n\r\nForbehold\r\n\r\nI en metapopulasjon så betyr det noe hvor bestandene er. Og hvilke som ligger hvor - ikke alle bestander er skapt like.\r\nHvilke områder kan gjøre nettverket sterkere?\r\nI en tidligere post om metapopulasjoner skrev vi om hvordan konnektivitet (\\(S_{i}\\)) i en metapopulasjon kan “enkelt” skildres basert på avstanden mellom delområdene (\\(d_{ij}\\)) og størrelsen av delområdene (\\(A_{i}A_{j}\\)). Større konnektivitet er ofte assosiert med høyere sannsynlighet for tilstedeværelse av en bestand (Ranius et al. (2014)). Endringene i andelen bebodde område (eller bestander), \\(p\\), kan beskrives med utvekslingene mellom områdene \\(i\\) og \\(j\\): \\(m_{ij} = e^{-\\alpha d_{ij}}A_{i}A_{j}\\).\r\nMan kan beskrive bevegelsen mellom alle områdene (dvs. for hele metapopulasjonen) med en kvadratisk matrise M hvor lengden (og bredden) er lik antall områder og fyller den med verdiene \\(m_{ij}\\). For denne matrisen så finner vi eigenverdien \\(\\lambda_{M}\\). \\(\\lambda_{M}\\) kalles også for metapopulasjonens kapasitet. Eigenverdien tilsvarer andel bebodde områder (\\(h\\) i modellene til Levins (1969), Levin (1970); også tilsvarende \\(p\\) i likning 3 her).\r\nParametrene som inngår i lambda M er teoretisk knyttet til bestandens overlevelse. Når \\(\\lambda_{M}>E/C\\) så vil bestanden være levedyktig i det lange løp. \\(C\\) - koloniseringsrate (hvor mange individ som forlater et områder i retning av alle andre områder). Noe som også er bekreftet eksperimentelt (Molofsky and Ferdy (2005), Govindan et al. (2015)) og i felt (Bulman et al. (2007)).\r\nMetapopulasjonskapasitet samsvarer i stor grad med rødlistevurderingene (Schnell et al. (2013a), Schnell et al. (2013b), Huang, Pimm, and Giri (2020)). IUCN har laget rammeverket for rødlistevurderingene som brukes både nasjonalt og internasjonalt. I dette rammeverket så blir bestander som er fordelt over flere små områder (‘several small’) vurdert til å være i en mer kritisk tilstand enn bestander som er samlet i færre større områder (‘single large’).\r\nEn av antagelsen ved modellen over er at spredning øker med arealet til bestanden. Dette medfører blant annet at en økning av arealet til en bestand sitt område øker metapopulasjonskapasiteten. Altså et stort område er bedre enn mange små. Men det er ikke alltid tilfelle at spredning øker med arealet (Wang and Altermatt (2019)). Hos noen arter, slik som gresshoppen vortebiter kan antallet som sprer seg bli mindre med økende områdestørrelse. Hos slike arter anbefales at man forsøker å ivareta mange små habitat.\r\nSlike forhold, og antagelsene om positive forhold mellom areal og immigrasjon og uttryddelsesrate kan bakes inn i forholdene gitt over (Ovaskainen (2002)), ved at økende areal kan ha en negativ eller positiv effekt på \\(m_i{ij}\\) ved å justere eksponenten \\(\\theta\\).\r\n\\(m_{ij} = e^{-\\alpha d_{ij}}A_{i}^{\\theta_{ex}+\\theta_{im}}A_{j}^{\\theta_{em}}\\).\r\nMen til å begynne med så forholder vi oss til det enkle (og forsåvidt mest utbredte) scenarioet om at økende areal av område øker spredning, øker overlevelse og immigrasjon. Vi simulerer først en rekke bestander basert på forholdene gitt i tidligere innlegg om metapopulasjoner.\r\n\r\n\r\nShow code\r\n\r\nlibrary(data.table)\r\nlibrary(ggplot2);library(cowplot);library(scales);library(gridExtra)\r\n\r\nnSimulations = 50\r\nParameterSpace = expand.grid(nIterations = 1:nSimulations,\r\n                             #RangeØyer = seq(40,60,length.out = 1),\r\n                             RangeStartProp = seq(.35,.6,length.out = 1),\r\n                             RangeLandskap = seq(3.4,3.7,length.out = 1),\r\n                             RangeKonstantC = seq(.24,.75,length.out =  1),# .23->.24\r\n                             RangeKonstantE = seq(60,100,length.out = 1),# 325->320\r\n                             eNoise = seq(0,0,length.out = 1))\r\nsetorder(ParameterSpace, nIterations)\r\n\r\nParameterSpace$SnittPrevalens = NA\r\nParameterSpace$SdPrevalens = NA\r\nParameterSpace$MinPrevalens = NA\r\nParameterSpace$AndelUtvikling = NA\r\niteration = 0\r\n# lengde på tidsserie\r\ntmax = 100\r\nRangeØyer = 40\r\nnØyer = RangeØyer # ParameterSpace$RangeØyer[i] #i\r\n\r\nTidsArray = array(rep(0, tmax*nØyer), \r\n                  dim = c(tmax, nØyer,  nrow(ParameterSpace)))\r\n\r\nTidsserieKoloniseringsrater = array(rep(0, tmax*nØyer), \r\n                                    dim = c(tmax, \r\n                                            nØyer, \r\n                                            nrow(ParameterSpace)))\r\n\r\nGeografiArray = array(rep(NA, 3*nØyer),\r\n                      dim = c(3, nØyer, nrow(ParameterSpace)))\r\n\r\nfor(i in 1:nrow(ParameterSpace)){\r\n  #print(paste(i , \"av\", nrow(ParameterSpace)))\r\n  # Antall øyer/habitat i systemet\r\n  \r\n  iteration <- ParameterSpace$nIterations[i]\r\n  \r\n  AntallBebodd = ParameterSpace$RangeStartProp[i]*nØyer #i\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  Bebodd = sample(1:nØyer,AntallBebodd)\r\n  \r\n  Tilstede = rep(0, nØyer)\r\n  Tilstede[Bebodd]<-1\r\n  \r\n  TidsserieTilstede = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\n  TidsserieTilstede[1,]<-Tilstede\r\n  \r\n  TidsArray[1,,iteration]<-Tilstede\r\n  TidsserieKoloniseringsrater[1,,iteration]<-Tilstede\r\n  \r\n  # tilfeldig plassering av øyene\r\n  ArenaStørrelse = ParameterSpace$RangeLandskap[i]\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  xPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  set.seed(-iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  yPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  \r\n  # Tilfeldig størrelse\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  ØyStr = rlnorm(n = nØyer, meanlog = .1, sdlog = .2) #Ai\r\n  \r\n  GeografiArray[,,i]<-rbind(ØyStr, xPos, yPos)\r\n  # Regn ut mellom-øy avstand\r\n  MellomØyAvstand = dist(cbind(xPos, yPos), diag = T, upper = T) # dij\r\n  Alpha = -1#1/mean(MellomØyAvstand)\r\n  # Konstanter\r\n  c_konstant = ParameterSpace$RangeKonstantC[i]\r\n  e_konstant = ParameterSpace$RangeKonstantE[i]\r\n  \r\n  eNoise = ParameterSpace$eNoise[i]\r\n  # Utryddelsesrater er konstant over tid\r\n  UtryddelsesRateØy_i = e_konstant/ØyStr\r\n  \r\n  # fra Hanski, Ilkka, et al. \"The quantitative incidence function model and persistence of an endangered butterfly metapopulation.\" Conservation Biology 10.2 (1996): 578-590.\r\n  # ØystrEffekt = 0.952\r\n  # muTick = 0.158\r\n  \r\n  # AjAi = sapply(ØyStr, function(x) x*ØyStr)\r\n  # mij = exp(-Alpha*as.matrix(MellomØyAvstand))*AjAi # number of immigrants\r\n  \r\n  # Tidssteg \r\n  t = 2\r\n  NoiseE = rnorm(n = tmax, sd = eNoise)\r\n  \r\n  while(t<tmax){\r\n    \r\n    KoloniseringsRateØy_i = sapply(1:nØyer, function(i){\r\n      Aj = ØyStr[-i]\r\n      Aj = Aj + NoiseE[t]\r\n      c_konstant*sum(Tilstede[-i]*Aj*\r\n                       exp(-Alpha*as.matrix(MellomØyAvstand)[-i,i]))}) # Si\r\n    \r\n    TidsserieKoloniseringsrater[t,,i]<-KoloniseringsRateØy_i\r\n    \r\n    # Sannsynligheten for bebodd øy\r\n    Pi = KoloniseringsRateØy_i/(KoloniseringsRateØy_i + UtryddelsesRateØy_i) # Også kjent som Ji\r\n    Pi = ifelse(Pi>1,1,ifelse(Pi<0,0,Pi))\r\n    \r\n    Kolonisert = sapply(Pi, function(x) sample(0:1, 1, prob = c(1-x,x)))\r\n    \r\n    # Oppdater bebodd-status\r\n    Tilstede<-Kolonisert\r\n    TidsserieTilstede[t,]<-Tilstede\r\n    TidsArray[t,,i]<-Tilstede\r\n    \r\n    # Oppdater tidssteg\r\n    t = t+1\r\n  }\r\n  \r\n  ParameterSpace$SnittPrevalens[i] = median(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$SdPrevalens[i] = sd(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$MinPrevalens[i] = min(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$AndelUtvikling[i] = coef(lm(rowMeans(TidsserieTilstede)~I(1:length(rowMeans(TidsserieTilstede)))))[2]\r\n  if(i==nrow(ParameterSpace)){\r\n    saveRDS(list(ParameterSpace = ParameterSpace,\r\n                 Geografi = GeografiArray,\r\n                 TidsArray = TidsArray,\r\n                 TidsserieKoloniseringsrater = TidsserieKoloniseringsrater),\r\n            \"ParameterSpace_MetaPopStoch.rds\")\r\n  }\r\n}\r\n\r\np1 = ggplot(data = ParameterSpace, aes(y = MinPrevalens, x = eNoise, group = factor(eNoise)))+geom_boxplot()+theme_cowplot()+\r\n  theme(axis.title.x = element_blank(),\r\n        axis.text.x = element_blank())+\r\n  ylab(\"Andel \\n (minimum)\")\r\np2 = ggplot(data = ParameterSpace,\r\n            aes(y = SnittPrevalens, \r\n                x = eNoise, group = factor(eNoise)))+\r\n  geom_boxplot()+theme_cowplot()+\r\n  theme(axis.title.x = element_blank(), \r\n        axis.text.x = element_blank())+\r\n  ylab(\"Andel \\n (gj.snitt)\")\r\n\r\np3 = ggplot(data = ParameterSpace,\r\n            aes(y = AndelUtvikling*200, x = eNoise,\r\n                group = factor(eNoise)))+\r\n  geom_hline(yintercept = 0, linetype=\"dashed\")+theme_cowplot()+\r\n  geom_boxplot()+\r\n  ylab(\"Andelsvekst\\n per år x 200\") +\r\n  xlab(\"Miljøstokastisitet\")#+\r\n#scale_y_continuous(breaks = seq(-.2,.2,.1))+coord_cartesian(ylim = c(-0.1,0.1))\r\n\r\nGeografi = GeografiArray#aa$Geografi\r\nTidsArray = TidsArray#aa$TidsArray\r\nTidsserieKoloniseringsrater = TidsserieKoloniseringsrater#aa$TidsserieKoloniseringsrater\r\n\r\n#### Centrality ####\r\n# Eigenvector centrality er et mål på hvor mange noder som peker til deg. \r\n# Per parametersetting\r\nCentrality = lapply(1:dim(Geografi)[3], function(x){\r\n  # Per landskap\r\n  dij = as.matrix(dist(cbind(Geografi[2,,x], Geografi[3,,x]), diag = T, upper = T))\r\n  Centrality = sapply(1:nrow(dij), function(i){\r\n    js = sapply(1:ncol(dij), function(j){\r\n      exp(dij[i,j])*Geografi[1,i,x]*Geografi[1,j,x]\r\n    })\r\n    js\r\n  })\r\n  diag(Centrality)<-0 # set i = j <- 0\r\n  Eigens = eigen(Centrality)\r\n  EVec = Eigens$vectors[,1]^2\r\n  EVec = EVec/sum(EVec)\r\n  \r\n  list(Eigenvector = EVec,\r\n       EigenValue = Eigens$value[1])\r\n}) \r\n\r\nParameterSpace$EigenvalueCentrality<-sapply(Centrality, function(x) x$EigenValue)\r\n\r\n## Connectivity ####\r\nAlpha = 1/1 # Alpha beskriver overlevelse for spredningen, dvs. 1/gjennomsnittlig spredningsdistanse\r\n# Per parametersetting\r\nConnectivity = lapply(1:dim(Geografi)[3], function(x){\r\n  # Per landskap\r\n  dij = as.matrix(dist(cbind(Geografi[2,,x], Geografi[3,,x]), diag = T, upper = T))\r\n  # Geographic aspect\r\n  Geo = exp(-Alpha*dij)*Geografi[1,,x]*dij # ganger en siste med dij for å ignorer i = j, dvs. avstand med seg selv\r\n  # Per tidssteg\r\n  Si_per_t = t(sapply(1:nrow(TidsArray), function(Tt){\r\n    # per øy\r\n    Si = sapply(1:ncol(TidsArray), function(xx){\r\n      Si_x = sum(Alpha*TidsArray[Tt,,x]*Geo[xx,])\r\n    })\r\n    Si\r\n  }))\r\n}) \r\n\r\nConnectivities = sapply(Connectivity, function(x){\r\n  colMeans(x)\r\n})\r\n\r\n\r\n### Eksempel\r\ndf = as.data.frame(t(Geografi[,,1]))\r\nnames(df)<- c(\"Areal\", \"xPos\", \"yPos\")\r\n\r\n#df$Connectivity = colMeans(t(Connectivities))\r\ndf$Connectivity = t(Connectivities)[1,]\r\ndf$EigenCentrality = Centrality[[1]]$Eigenvector^2*Centrality[[1]]$EigenValue\r\n\r\nParameterSpace = as.data.table(ParameterSpace)\r\nParameterSpace[,AverageConnectivity:=colMeans(Connectivities)]\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\n# Øyer som har bedre tilknytning har bedre vekst\r\nggplot(data = ParameterSpace,\r\n       mapping = aes(x = (EigenvalueCentrality), \r\n                     y = AndelUtvikling))+\r\n  geom_point()+\r\n  geom_smooth(method = \"lm\", se=FALSE)+\r\n  xlab(\"Metapopulasjonkapasitet\")+\r\n  ylab(\"Vekst i andel\\n bebodde områder\") +\r\n  coord_cartesian(ylim = quantile(ParameterSpace$AndelUtvikling,c(.1,.9))) \r\n\r\n\r\n\r\nFigure 1: Gjennomsnittlig vekst i andel bebodde områder med økende metapopulasjonskapasitet. Linjen viser en lineær regresjon.\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nggplot(data = ParameterSpace,\r\n       mapping = aes(x = (EigenvalueCentrality), \r\n                     y = SnittPrevalens))+\r\n  geom_point()+\r\n  geom_smooth(method = \"glm\", \r\n              method.args = list(family = \"binomial\"), \r\n              se = FALSE)+\r\n  xlab(\"Metapopulasjonkapasitet\")+\r\n  ylab(\"Andel bebodde områder \\n (gj.snitt)\")+\r\n  coord_cartesian(ylim = quantile(ParameterSpace$SnittPrevalens\r\n                                  ,c(.1,.9))) \r\n\r\n\r\n\r\nFigure 2: Gjennomsnittlig andel bebodde områder med økende metapopulasjonskapasitet. Linjen viser en logistisk regresjon.\r\n\r\n\r\n\r\nLa oss nå se på et mer konkret eksempel.\r\nNye verneområder\r\nNoen ganger har man mulighet til å utvide området man legger ned innsats i; ved å utvide skjøtselen til nye områder, ved å etablere nye verneområder mm.\r\nVi kan ta utgangspunkt i dagens verneområder i Rogaland fylke. Her er det meldt at fire nye områder kan være aktuelle for vern.\r\nBlant disse, av Klostervågen og Mosvatnet: hvilket område burde man velge?\r\nMed metodikken over så kan vi første ta dagens situasjon med alle verneområder; hvor de ligger og hvor store de er. Man ender da opp med en metapopulasjonskapasitet \\(\\lambda_{M}\\) = 169.92, og ja legger man til både Klostervåen og Mosvatnet så blir dette best. Men, om man bare må velge et så kan det synes som at Klostervågen (\\(\\lambda_{M}\\) = 170.74) slår Mosvatnet (\\(\\lambda_{M}\\) = 170.12) såvidt. Eller, enhetene her er jo vanskelig å oversette uten mer kontekst. Så for alt vi vet så kan dette være en ganske stor forskjell.\r\n\r\n\r\nShow code\r\n\r\nlibrary(data.table)\r\nlibrary(sf)\r\nlibrary(ggmap)\r\nlibrary(mapproj)\r\nlibrary(cowplot)\r\nlibrary(gridExtra)\r\nth = theme_cowplot()+\r\n  theme(axis.text=element_blank(),axis.title=element_blank(), legend.position = \"none\")\r\nlibrary(sp)\r\n\r\nVO = fread(\"Verneomraader_centroider.csv\")\r\n#VO = VO[-1,]\r\n#Mosvatnet\r\n#531039,61; N: 6539879 Ø: 310963\r\n# Klostervågen\r\n#847287,21; N: 6556056 Ø: 304732\r\n\r\n\r\n\r\n# Hettemåke foraging flight 4.6-11.8 km flight range # https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.6291\r\n# sildemåke 30.9 #https://www.researchgate.net/publication/306119852_Terrestrial_and_Marine_Foraging_Strategies_of_an_Opportunistic_Seabird_Species_Breeding_in_the_Wadden_Sea/link/57b2ef8508aeaf239baefb27/download\r\n\r\n\r\n\r\nGeografi = VOgeo = as.matrix(VO[,c(\"Areal\", \"PosX\", \"PosY\")])\r\nVOgeo1 = rbind(VOgeo, c(847287.21, 304732, 6556056)) # Klostervågen\r\nVOgeo2 = rbind(VOgeo, c(531039.61, 310963, 6539879)) # Mosvatnet\r\nVOgeo3 = rbind(VOgeo2, c(847287.21, 304732, 6556056)) # Begge to\r\n\r\nCentrality = function(Geografi, DispersalDistance = 30.9, Alpha = NULL, unit = \"m\"){\r\n  # Geografi = dataramme med areal, x og y koordinate\r\n  Areal = Geografi[,1]\r\n  \r\n  if(unit==\"m\"){\r\n    Areal = Areal/1000000\r\n  }\r\n  \r\n  dij = as.matrix(dist(cbind(Geografi[,2], Geografi[,3]), diag = T, upper = T))\r\n  if(unit == \"m\"){\r\n    dij = dij/1000# transform from meter to kilometer\r\n    \r\n  }\r\n  \r\n  \r\n  Alpha = 1/DispersalDistance\r\n  \r\n  Si = sapply(1:nrow(Geografi), function(i){\r\n    Geo = sum(exp(-Alpha*dij[i,-i])*Geografi[-i,1]) \r\n  })\r\n  \r\n  M = sapply(seq_along(Areal), function(i){\r\n    sapply(seq_along(Areal), function(j){\r\n      exp(-Alpha*dij[i,j])*Areal[i]*Areal[j]\r\n    })\r\n  })\r\n  \r\n  diag(M)<-0\r\n  ev = eigen(M)$vectors[,1]^2\r\n  ev = ev/(sum(ev))\r\n  we = ev*eigen(M)$value[1]\r\n  \r\n  \r\n  list(Centrality = Si,\r\n       EigenValue = eigen(M)$value[1],\r\n       Eigenvectors = we)\r\n}\r\n\r\nMeasures = Centrality(Geografi = VOgeo)\r\nPlotting = function(Geografi = VOgeo3, AntallNye = 0){\r\n  InputData = as.data.frame(Geografi)\r\n  \r\n  pp = st_as_sf(SpatialPoints(coords = InputData[,2:3]))\r\n  st_crs(pp)<-32632\r\n  bb = st_bbox(pp)\r\n  pp2 = st_transform(pp, 4326)\r\n  \r\n  VOs = data.frame(st_coordinates(st_transform(pp, 4326)))\r\n  names(VOs)<-c(\"PosX\", \"PosY\")\r\n  VOs$EV = log(Centrality(Geografi = InputData)$Eigenvectors)\r\n  \r\n  ## Plot kartet\r\n  aaa = get_map(c(left = min(VOs[,1])-.2, \r\n                  right = max(VOs[,1])+.2,\r\n                  bottom = min(VOs[,2])-.2, \r\n                  top = max(VOs[,2])+.2))\r\n  \r\n  Labs = data.frame(Y = max(VOs$PosY),#as.numeric(attr(aaa, \"bb\")[3]),\r\n                    X = min(VOs$PosX),#as.numeric(attr(aaa, \"bb\")[2]), \r\n                    MC = paste(\"Metapopulasjonskapasitet = \",\r\n                               round(Centrality(Geografi = \r\n                                                  InputData)$EigenValue,2)))\r\n  \r\n  ggmap(aaa)+\r\n    xlab(\"Lengdegrad\")+ ylab(\"Breddegrad\")+theme_cowplot()+\r\n    geom_point(data= VOs, \r\n               mapping = aes(x = PosX, y = PosY,\r\n                             size = EV, col = EV))+\r\n    geom_point(data = as.data.frame(tail(VOs,AntallNye)),\r\n               mapping = aes(x = PosX, y = PosY), col = \"red\")+\r\n    geom_label(data = Labs, \r\n               mapping = aes(y = Y, x = X,\r\n                             label = MC),\r\n               fontface = \"bold\", fill = alpha(\"white\",0.5),\r\n               hjust = 0.05, vjust = -.7)+\r\n    th\r\n\r\n  }\r\n\r\n#grid.arrange(\r\n  Plotting(VOgeo)+coord_fixed()#,\r\n\r\n\r\nShow code\r\n\r\n             Plotting(VOgeo1, \r\n                      AntallNye = 1)+coord_fixed()#,\r\n\r\n\r\nShow code\r\n\r\n             Plotting(VOgeo2, \r\n                      AntallNye = 1)+coord_fixed()#,\r\n\r\n\r\nShow code\r\n\r\n             Plotting(VOgeo3, \r\n                      AntallNye = 2)+coord_fixed()#, ncol = 4, nrow = 1)\r\n\r\n\r\n\r\nDet kan gi mening at Klostervågen er vurdert til bedre. Den økter “tettheten” av verneområder i et område med lavere tetthet enn omgivelsen til Mosvatnet. Men merk. Her så pøser vi jo inn bare areal på verneområdene. Hvor enunderliggende antagelse er at større område betyr bedre kvalitet. Areal er uten tvil viktig for kvaliteten til det enkelte området, men sammensetningen til området - hvilke naturtyper den består av - er også svært viktig (jf. nisje-konseptet). Og fullstendig ignorert her.\r\nHvilke områder er viktige?\r\nOm man nå har en rekke delområder som man skal skjøtte eller forvalte på noe vis, hvor skal man legge ned innsats?\r\nEigenverdien, \\(\\lambda_{M}\\), til metapopulasjonen har en assosiert høyre eigenvektor. Denne har likt antall verdier (\\(x\\)) som antall bestander i systemet, og kan brukes til å beskrive den enkelte bestanden sin betydning for metapopulasjonen sin kapasitet. Hvor hvert tall i eigenvektoren (\\(x_{i}\\), heretter kallt \\(EV\\)) kvadrert og multiplisert med \\(\\lambda_{M}\\) vil gi dette målet; \\(\\lambda_{i} = \\lambda_{M}EV^2\\). Eigenvektoren til \\(M\\)-matrisen er blitt brukt for å identifisere viktige områder for bevaring av fugler i den atlantiske regnskogen (Huang, Pimm, and Giri (2020)).\r\nI populasjonsøkologi tilsvarer vektoren den stabile aldersfordelingen om \\(M\\)-matrisen var Leslie-matrisen til en bestand. Og kan tolkes likedan; over tid så vil verdiene i eigenvektorene reflektere hvor det befinner seg flest individer i bestanden. Og hvor man i populasjonsøkologi vil regne ut sensitivitet/elastisitet for å beregne hvilken parameter i Leslie-matrisen (f.eks. overlevelse eller fekunditet til en gitt aldersklasse) som er viktigst for bestandsveksten, så blir dette overflødig for \\(M\\)-matrisen da den er symmetrisk. Dette betyr også at sensitivitet/elastisitet samsvarer med \\(EV\\). Kan også se til denne studien for beregning av sensitivitet/elastisitet.\r\nDragehode og dragehodeglansbille\r\nDragehode er en truet art, som er vertsplante for den enda mer truede dragehodeglansbillen.\r\nFor disse artene så brukes det mye tid og penger på tiltak. Metapopulasjonsteori kan være en tilnærming på hvordan man skal prioritere hvor man bør gjøre tiltakene.\r\nVi henter data fra GBIF (Artskart) for disse to artene. Og antar at dragehodeglansbille har en gjennomsnittlig spredningsdistanse på ca. 1500 meter. Vi kjører først en algoritme som grupperer forekomstene slik at de som er innenfor 1500 m fra hverandre blir gruppert sammen og utgjør en “bestand.” Slik at bevelse innenfor denne avstanden er “normal” bevegelse, mens bevegelse utover dette er “spredning.”\r\n\r\n\r\nShow code\r\n\r\n#install.packages(\"rgbif\")\r\nlibrary(rgbif)\r\n#library(scrubr)\r\nlibrary(maps)\r\nlibrary(data.table)\r\nlibrary(sp)\r\nlibrary(raster)\r\nlibrary(ggplot2)\r\nlibrary(cowplot)\r\nlibrary(adehabitatHR)\r\n\r\nmyspecies <- c(\"Meligethes norvegicus\",\"Dracocephalum ruyschiana\")\r\n\r\nif(!file.exists(\"C:/Users/endre/OneDrive/Tekster/egodrive.github.io/_posts/2022-10-01-metapopulasjoner-del-2/gbif_data.csv\")){\r\ngbif_data <- occ_data(scientificName = myspecies, \r\n                      hasCoordinate = TRUE,\r\n                      country = \"NO\", \r\n                      limit = 20000)\r\n\r\nHost = data.table( gbif_data$`Dracocephalum ruyschiana`$data)\r\nBeetle = data.table(gbif_data$`Meligethes norvegicus`$data)\r\n\r\nJoint = rbind(Beetle, Host, fill = T)\r\nJoint$networkKeys<-NULL\r\nfwrite(Joint,\"C:/Users/endre/OneDrive/Tekster/egodrive.github.io/_posts/2022-10-01-metapopulasjoner-del-2/gbif_data.csv\")\r\n}\r\nJoint = fread(\"C:/Users/endre/OneDrive/Tekster/egodrive.github.io/_posts/2022-10-01-metapopulasjoner-del-2/gbif_data.csv\")\r\n\r\nJoint = Joint[decimalLatitude>58.5 & decimalLatitude<62]\r\n\r\nJoint = cbind(data.table(coordinates(spTransform(\r\n  SpatialPoints(coords = Joint[,c(\"decimalLongitude\", \"decimalLatitude\")],\r\n                proj4string = CRS(\"+init=epsg:4326\")),\r\n  CRS(\"+init=epsg:32632\"))))\r\n  , Joint)\r\nnames(Joint)[1:2]<-c(\"UTMx\", \"UTMy\")\r\n\r\n\r\n\r\nDispDistanceM = 1500\r\n\r\n# Create clusters, aka. populations\r\nssp = Joint[,c(1:2)]\r\nchc <- hclust(dist(ssp), method=\"complete\")\r\n\r\n# Distance with a 1500 threshold  \r\nchc.d <- cutree(chc, h=DispDistanceM) \r\nJoint[,Populasjon:=chc.d]\r\n\r\n# Lage et grid (kan brukes til å definere populasjon)\r\n#Joint[,c(\"gridY\", \"gridX\"):=list(cut(UTMy, seq(from = min(Joint$UTMy, na.rm = T),\r\n#                                               to  = max(Joint$UTMy, na.rm = T),\r\n#                                               by = DispDistanceM)),\r\n#                                 cut(UTMx, seq(from = min(Joint$UTMx, na.rm = T),\r\n#                                               to  = min(Joint$UTMx, na.rm = T),\r\n#                                               by = DispDistanceM)))]\r\n# Finne sentrum hvor hver populasjon\r\nJoint[,c(\"centrY\", \"centrX\"):=list(mean(UTMy, na.rm = T),\r\n                                   mean(UTMx, na.rm = T)),\r\n      c(\"Populasjon\")]\r\n\r\nJoint[,Areal:={try(mcp(SpatialPoints(.SD[,c(\"UTMx\", \"UTMy\")]), percent = 100)$area,\r\n                   silent = T)},\r\n      \"Populasjon\"]\r\nJoint[,Areal:=ifelse(is.na(Areal)|Areal==0,min(Joint$Areal, na.rm = T),Areal)]\r\n\r\nJoint[,nHost := (max(.SD[species==\"Dracocephalum ruyschiana\"]$individualCount,\r\n                     na.rm = T)),\r\n      c(\"Populasjon\")]\r\nJoint[, nHost:=ifelse(is.na(nHost),.1,nHost)]\r\nJoint[,BeetlePresent:=uniqueN(species)-1, c(\"Populasjon\")]\r\n#Joint[,BeetlePresent:=ifelse(BeetlePresent==1,\"Ja\",\"Nei\")]\r\n\r\nif(\"metapop\" %in% installed.packages()[,1]){\r\n  library(metapop)\r\n}else{install.packages(\"metapop\", repos = c(\"http://R-Forge.R-project.org\",\r\n                                            \"http://your.nearest.CRAN.mirror.org\"), dep = TRUE)\r\n}\r\nd = dist(Joint[centrY>0,.SD[1], c(\"Populasjon\")][,c(\"centrX\", \"centrY\")])\r\nAr = as.numeric(Joint[centrY>0,.SD[1], c(\"Populasjon\")]$Areal)\r\niD = 1/DispDistanceM\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nlibrary(data.table);library(scales)\r\nlibrary(cowplot);library(metapop)\r\nlibrary(ggplot2)\r\n\r\nmetacapa_2 = function(d, A, alpha = 1, ...){\r\n M<- as.matrix(exp(-alpha*d))\r\n diag(M)<- 0\r\n M<-M * outer(A, A)\r\n tmp <- eigen(M)\r\n #tmp2 <- eigen(t(M))\r\n \r\n ev <- tmp$values[1]\r\n \r\n eij = (M/ev)*((tmp$vectors[, 1]*tmp$vectors[, 1])/(tmp$vectors%*%tmp$vectors))\r\n \r\n \r\n \r\n cap <- list(capacity = ev, x = tmp$vectors[, 1]^2, d = d, \r\n             A = A, \r\n             M = M)\r\n class(cap) <- \"metacapa\"\r\n cap\r\n }\r\n\r\nsol <- metacapa_2(d, Ar,\r\n                alpha = iD)\r\n\r\nJoint = cbind(Joint[centrY>0,.SD[1], c(\"Populasjon\")][,c(\"Populasjon\")],EV = sol$x\r\n)[Joint, on = \"Populasjon\"]\r\n\r\np = ggplot(data = Joint[Areal>4 & nHost >0.1],\r\n       aes( y = (nHost), x = (Areal)))+\r\n  geom_point(mapping = aes(col = factor(BeetlePresent), size = EV))+\r\n  theme_cowplot()+\r\n  geom_smooth(method = \"glm\", \r\n              method.args = list(family = \"poisson\"), \r\n              se = FALSE)+\r\n  scale_color_discrete(name=\"Dragehodeglansbille\\ntilstede\")+\r\n  xlab(\"Areal (ha)\") + ylab(\"Dragehode (antall)\")+\r\n  theme(legend.position=\"bottom\")\r\n  \r\np + \r\n  scale_x_continuous(breaks= log_breaks(),trans = scales::log_trans())+\r\n  scale_y_continuous(breaks= log_breaks(),trans = scales::log_trans())\r\n\r\n\r\n\r\nFigure 3: Forholdet mellom antall dragehode i en bestand og areal på bestanden, hvor punktstørrelsen reflekterer EV (verdien bestanden har for metapopulasjonen av dragehode) og fargen om det er en bille tilstede eller ikke. Linjen viser en poisson-regresjon.\r\n\r\n\r\n\r\nShow code\r\n\r\ndf = Joint[Areal>4 & nHost >0.1][,.SD[1], \"Populasjon\"]\r\n\r\n\r\nMan kan også se på \\(EV\\) som en forklaring på om dragehodeglansbille er tilstede. Jo mer robust del av vertsbestanden man er i, jo mer sannsynlig vil det være å finne dragehodeglansbille. Det er forsåvidt en statistisk signifikant forhold, men merk: her har vi ikke gått dataene nærmere etter i sømene. Så dette “forholdet” må man ta med god klype salt (det er så mange bestander med, og det utvalget vi har er kanskje ikke samlet inn “godt nok”).\r\n\r\n\r\nShow code\r\n\r\nlibrary(cowplot)\r\nlibrary(ggplot2)\r\nggplot(data = df, aes(y = BeetlePresent, x = EV))+\r\n  geom_point()+\r\n  geom_smooth(method = \"glm\", \r\n              method.args = list(family = \"binomial\"), \r\n              se = FALSE)+\r\n  ylab(\"Bille tilstede\")\r\n\r\n\r\n\r\nFigure 4: Forholdet mellom hvorvidt dragehodeglansbille er tilstede og delområdet sin EV (rolle i metapopulasjonen) av dragehode.\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nknitr::opts_chunk$set(echo = FALSE)\r\nlibrary(leaflet)\r\nlibrary(leaflegend)\r\nlibrary( crosstalk )\r\nlibrary( dplyr )\r\n\r\n\r\ndf = Joint[,.(lat = mean(decimalLatitude, na.rm = T),\r\n              long = mean(decimalLongitude, na.rm = T),\r\n              BeetlePresent = unique(BeetlePresent), \r\n              mag = mean(EV, na.rm = T)),\r\n      c(\"Populasjon\")]\r\n\r\ndf = df[df$lat>0 & df$long>0,]\r\n#df$mag <- (df$mag-min(df$mag, na.rm = T))/(max(df$mag, na.rm = T)-min(df$mag,na.rm = T))\r\ndf$mag<-ecdf(df$mag)(df$mag)\r\n\r\n# symbols <- makeSymbolsSize(\r\n#   values = df$mag,\r\n#   shape = 'diamond',\r\n#   #color = 'red',\r\n#   color = ~pal(df$mag2), \r\n#   #fillColor = 'red',\r\n#   opacity = .5,\r\n#   baseSize = 10\r\n# )\r\n\r\n\r\n# If you want to use predefined palettes in the RColorBrewer package:\r\n# Call RColorBrewer::display.brewer.all() to see all possible palettes\r\npal <- colorNumeric(\r\n  palette = 'YlOrRd',\r\n  domain = df$mag2\r\n)\r\n\r\ndf$mag2 = df$mag\r\nshared_data <- SharedData$new(df)\r\n\r\nfilter_slider(\"mag\", \"Metpop-verdi\", shared_data, ~mag2, width = \"100%\")\r\n\r\n\r\nMetpop-verdi\r\n\r\n\r\nShow code\r\n\r\nleaflet(shared_data) %>%\r\n  addTiles() %>%\r\n  addCircleMarkers(#lng = ~lng, lat = ~lat\r\n             , weight = 1\r\n             #, shape = 'diamond'\r\n             #, opacity = 0.1\r\n             , stroke = T\r\n             #, size = 10\r\n             #, radius = ~size\r\n             , popup = paste0(round(df$mag,2)*100,\"-persentil\")\r\n             , color = ~pal(mag2)\r\n             , fillColor = ~pal(mag2)\r\n             #, clusterOptions = markerClusterOptions()\r\n             )\r\n\r\n\r\n\r\nForbehold\r\nEn (av kanskje flere) ting som ikke er nevnt i angående metapopulasjoner så langt. Bestandsdynamikk i den enkelte bestand.\r\n\r\n\r\n\r\nBulman, Caroline R, Robert J Wilson, Alison R Holt, Lucı́a Gálvez Bravo, Regan I Early, Martin S Warren, and Chris D Thomas. 2007. “Minimum Viable Metapopulation Size, Extinction Debt, and the Conservation of a Declining Species.” Ecological Applications 17 (5): 1460–73.\r\n\r\n\r\nGovindan, Byju N, Zhilan Feng, Yssa D DeWoody, and Robert K Swihart. 2015. “Intermediate Disturbance in Experimental Landscapes Improves Persistence of Beetle Metapopulations.” Ecology 96 (3): 728–36.\r\n\r\n\r\nHuang, Ryan, Stuart L Pimm, and Chandra Giri. 2020. “Using Metapopulation Theory for Practical Conservation of Mangrove Endemic Birds.” Conservation Biology 34 (1): 266–75.\r\n\r\n\r\nLevin, Simon A. 1970. “Community Equilibria and Stability, and an Extension of the Competitive Exclusion Principle.” The American Naturalist 104 (939): 413–23.\r\n\r\n\r\nLevins, Richard. 1969. “Some Demographic and Genetic Consequences of Environmental Heterogeneity for Biological Control.” American Entomologist 15 (3): 237–40.\r\n\r\n\r\nMolofsky, Jane, and Jean-Baptiste Ferdy. 2005. “Extinction Dynamics in Experimental Metapopulations.” Proceedings of the National Academy of Sciences 102 (10): 3726–31.\r\n\r\n\r\nOvaskainen, Otso. 2002. “Long-Term Persistence of Species and the SLOSS Problem.” Journal of Theoretical Biology 218 (4): 419–33.\r\n\r\n\r\nRanius, Thomas, Petter Bohman, Olof Hedgren, Lars-Ove Wikars, and Alexandro Caruso. 2014. “Metapopulation Dynamics of a Beetle Species Confined to Burned Forest Sites in a Managed Forest Region.” Ecography 37 (8): 797–804.\r\n\r\n\r\nSchnell, Jessica K, Grant M Harris, Stuart L Pimm, and Gareth J Russell. 2013a. “Estimating Extinction Risk with Metapopulation Models of Large-Scale Fragmentation.” Conservation Biology 27 (3): 520–30.\r\n\r\n\r\n———. 2013b. “Quantitative Analysis of Forest Fragmentation in the Atlantic Forest Reveals More Threatened Bird Species Than the Current Red List.” PLoS One 8 (5): e65357.\r\n\r\n\r\nWang, Shaopeng, and Florian Altermatt. 2019. “Metapopulations Revisited: The Area-Dependence of Dispersal Matters.” Ecology 100 (9): e02792.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-10-01-metapopulasjoner-del-2/metapopulasjoner-del-2_files/figure-html5/AndelVekst-1.png",
    "last_modified": "2023-08-07T10:16:59+02:00",
    "input_file": {}
  },
  {
    "path": "posts/Metapopulasjoner/",
    "title": "Metapopulasjoner",
    "description": "For vi er legion.",
    "author": [
      {
        "name": "Endre Grüner Ofstad",
        "url": {}
      }
    ],
    "date": "2022-10-16",
    "categories": [
      "Økologi",
      "Økosystem"
    ],
    "contents": "\r\n\r\nContents\r\nØyer\r\nAlt er en plass\r\nI gode og onde dager\r\n\r\nEn bestand er sjeldent alene. Man finner ofte flere bestander av samme art spredt utover landskapet. Noen bestander er store, andre små. Noen ligger tett sammen, andre ligger mer isolert. Felles kalles disse bestandene (populasjonene) for en metapopulasjon (Levins (1969), Levin (1970)), eller ‘populasjon av populasjoner.’ Hvor landskapet mellom bestandene blir omtalt som ‘matrisen.’\r\n\r\n\r\nShow code\r\n\r\nlibrary(ggmap)\r\nlibrary(mapproj)\r\nlibrary(cowplot)\r\naa = ggmap(get_map(c(left = 12.43, right = 12.55,bottom = 66.35, top = 66.40)))+\r\n  xlab(\"Lengdegrad\")+ ylab(\"Breddegrad\")+theme_cowplot()\r\naa\r\n\r\n\r\n\r\nFigure 1: Øyene langs kysten av Lovund i Nordland er habitat hvor fastlandsarter som vånd vil kunne danne bevege seg mellom og danne bestander. Antallet og hvor man finner individ vil variere med arealet og avstanden mellom øyene.\r\n\r\n\r\n\r\nHvis en ser \\(N\\) bestander som kan finnes på \\(T\\) forskjellige steder (habitat) i landskapet så vil \\(x\\) antall av bestandene bli utryddet hvert år (utryddelsesrate), mens \\(m'\\) nye bestander etableres hvert år (immigrasjonsrate). Noen habitat har bestander hvert år, mens andre habitat har mer flyktige bestander som opptrer bare noen år om annen.\r\nEndring i antall bestander hvert år (\\(t\\)) kan da beskrives som\r\n\\[\\begin{equation}\r\n\\frac{dN}{dt} = m'N(T-N)-XN \\tag{1}\r\n\\end{equation}\\]\r\nHvis en så setter \\(p = N/T\\) hvor \\(p\\) er andelen av områder med en bestand , og \\(m = m'T\\), vil gjøre likningen over til\r\n\\[\\begin{equation}\r\n\\frac{dp}{dt} = mp(1-p) - xp \\tag{2}\r\n\\end{equation}\\]\r\nsom beskriver endringen i andelen av områder med en bestand per år. Hvis endringen er 0, altså systemet er stabilt, vil andelen bebodde habitat være:\r\n\\[\\begin{equation}\r\n\\hat{p} = 1-x/m \\tag{3}\r\n\\end{equation}\\]\r\nDisse formlene er lik noen av formlene man også bruker for å beskrive bestandsvekst (logistisk vekst) hvor formel (3) tilsvarer bæreevnen i logistisk vekst.\r\nØyer\r\nMatrisen, området mellom bestandene, kan også være havet og områdene vi ser på være faktiske øyer. Og vi ser ikke på om et området har en bestand eller ikke, men hvor mange arter som finnes der. Vi snakker da om øybiogeografi (MacArthur and Wilson (2016)). I øybiogeografi er antall arter på en øy avhengig av:\r\nAvstand til fastlandet (hvor en antar at alle aktuelle arter finnes): jo lengre unna øya er fastlandet dess færre arter (2).\r\nStørrelsen på øya: jo større øya er dess flere arter (2).\r\nTid isolert: jo kortere tid øya har vært isolert fra fastlandet dess flere arter har den.\r\n\r\n\r\nShow code\r\n\r\nplot(seq(0, 20, by = 2), type = \"l\", lty = 2, xlab = \"Antall arter\", ylab = \"Innvandringer/Utryddelser\", col = \"turquoise\")\r\nlines(seq(0, 8, by = .8), col = \"turquoise\")\r\nlines(seq(8, 0, by = -.8), col = \"coral\")\r\nlines(seq(18, 0, by = -1.8), lty = 2, col = \"coral\")\r\ntext(x = 2, y = 8, \"Fjernt\")\r\ntext(x = 3, y = 16, \"Nært\")\r\ntext(x = 9, y = 8, \"Stor øy\")\r\ntext(x = 8, y = 16, \"Liten øy\")\r\n\r\n\r\n\r\nFigure 2: Hvordan antall inndvandringer og utvandringer er avhengig av avstand til fastland og arealet.\r\n\r\n\r\n\r\nHvis en kan velge blant \\(P\\) arter på fastlandet vil en øy på et gitt tidspunkt t ha S antall arter (gitt invasjonsrate \\(i_{\\alpha}\\) og utryddelsesrate \\(e_{\\alpha}\\) for art \\(\\alpha\\), Simberloff and Wilson (1970)).\r\n\\[\r\nS(t) = \\sum_{\\alpha = 1}^{P} \\frac{i_{\\alpha}}{i_{\\alpha} + e_{\\alpha}}(1-e^{-(i_{\\alpha}+e_{\\alpha})t}) \r\n\\] Per år så vil antall arter på en øy (\\(S_{s}\\)) kunne forandre seg ut fra \\[\\frac{dS_s}{dt} = i(P - S_s) - eS_s \\]\r\nEn vil så kunne se hvordan immigrasjon- og utryddelsesraten (hhv. \\(I(t)\\) og \\(E(t)\\)) endrer seg over tid. Hvor \\(S_{\\alpha}(t)\\) er lik 1 hvis arten \\(\\alpha\\) er tilstede på øya ved tidspunkt \\(t\\), og 0 ellers. Over tid vil disse kunne gå mot stabile verdier (3).\r\n\\[\r\nI(t) = \\sum_{\\alpha = 1}^{P} i_{\\alpha}- \\frac{i_{\\alpha}^{2}}{i_{\\alpha} + e_{\\alpha}}(1-e^{-(i_{\\alpha}+e_{\\alpha})t}) =  \\sum_{\\alpha = 1}^{P} i_{\\alpha}  - i_{\\alpha}S_{\\alpha}(t)\r\n\\]\r\n\\[\r\nE(t) = \\sum_{\\alpha = 1}^{P} i_{\\alpha}- \\frac{i_{\\alpha}e_{\\alpha}}{i_{\\alpha} + e_{\\alpha}}(1-e^{-(i_{\\alpha}+e_{\\alpha})t}) =  \\sum_{\\alpha = 1}^{P} e_{\\alpha}S_{\\alpha}(t)\r\n\\]\r\n\r\n\r\nShow code\r\n\r\n# install package from http://cran.nexr.com/web/packages/island/index.html\r\ni_rates = rexp(n = 10, rate = 1.2)\r\ne_rates = rexp(n = 10, rate = .9)\r\n\r\nidx = seq(from = 0, to = 5, by = .1)\r\nSs = sapply(idx, function(x){\r\n  sum((i_rates/(i_rates+e_rates))*(1 - exp(-(i_rates+e_rates)*x)))\r\n})\r\nIt = sapply(idx, function(x){\r\n  sum(i_rates-(i_rates^2/(i_rates+e_rates))*(1 - exp(-(i_rates+e_rates)*x)))\r\n})\r\n\r\nEt = sapply(idx, function(x){\r\n  sum(((i_rates*e_rates)/(i_rates+e_rates))*(1 - exp(-(i_rates+e_rates)*x)))\r\n})\r\n\r\npar(mfrow = c(3,1), omi = c(0,0,0,0), mar = c(5,5,0,0), bty = \"L\")\r\nplot(It~idx, xlab = \"Tidssteg\", ylab = \"Antall nye arter per tidssted\", type = \"l\")\r\nplot(Et~idx, xlab = \"Tidssteg\", ylab = \"Antall tapte arter per tidssteg\", type = \"l\")\r\nplot(Ss~idx, xlab = \"Tidssteg\", ylab = \"Antall arter på øya\", type = \"l\")\r\n\r\n\r\n\r\n\r\nFigure 3: Hvordan systemet vil konvergere til stabile verdier over tid.\r\n\r\n\r\n\r\nAlt er en plass\r\nLevin (1970) antok at 1) alle habitat er like og derfor lik migrasjonsrater til og fra alle habitat, og 2) at habitat er enten bebodd eller ubebodd. Men alle habitat er ikke like: noen er små, store gode, dårlige, nærme eller fjernt unna. Dette vil igjen påvirke hvor mange individ som migrerer mellom habitat, ikke bare hvorvidt en øy er bebodd eller ikke. Hanski (1994) viser hvordan vi kan ta hensyn til dette (kan også anbefale å lese Hanski and Ovaskainen (2000)).\r\nMan antar utryddelsesraten synker dess større habitatet er, \\(E_{i} = \\frac{e}{A_{i}^{x}}\\). Mindre habitat har mindre bestander som lettere kan bli utryddet av rovdyr eller andre tilfeldigheter. Mens immigrasjonsraten (\\(S_{i}\\)) er avhengig av habitatene omkring. Immigrasjonsrate er avheging av om det er individ der (\\(p_{j}\\)), og øker med størrelsen (\\(A_{j}\\)) til habitatene rundt, men synker med økende avstand (\\(d_{ij}\\)) til de: \\(S_{i} = c \\sum_{j = 1}^{N} = p_{j}A_{j}e^{(-\\alpha d_{ij})}\\)1. Med det utgangspunktet så kan vi se på hvordan en metapopulasjon oppfører seg.\r\nDen virkelige verden er ikke et tilfeldig utvalg. Den har kanskje kommet dit som en rekke av tilfeldige hendelser, men hvor den stopper er ikke tilfeldig. Slik at en kan ikke velge hva som helst av verdier for øystørrelse, avstander og forvente at metapopulasjonen vil eksistere over tid. Som er hva vi ser rundt oss mesteparten av tiden. Slik at jeg måtte leke litt rundt for å finne ut hvilke verdier vi må jobbe med. Trykk ‘Show code’ for å se koden hvor vi leter fram til “fornuftige” utvalg av parameterverdier å velge blant.\r\n\r\n\r\nShow code\r\nlibrary(ggplot2);library(ggExtra);library(data.table)\r\nParameterSpace = expand.grid(nIterations = 1:3,\r\n                             RangeØyer = seq(40,60,length.out = 1),\r\n                             RangeStartProp = seq(.2,.4,length.out = 3),\r\n                             RangeLandskap = seq(3.1,3.7,length.out = 3),\r\n                             RangeKonstantC = seq(.45,.75,length.out =  3),\r\n                             RangeKonstantE = seq(75,100,length.out = 5))\r\nParameterSpace$SnittPrevalens = NA\r\nParameterSpace$SdPrevalens = NA\r\n\r\nfor(i in 1:nrow(ParameterSpace)){\r\n  print(paste(i , \"av\", nrow(ParameterSpace)))\r\n  # Antall øyer/habitat i systemet\r\n  nØyer = ParameterSpace$RangeØyer[i] #i\r\n  \r\n  # lengde på tidsserie\r\n  tmax = 25\r\n  \r\n  # Sett et frø for utgangspunkt\r\n  #set.seed(999)\r\n  # Tilfeldig antall øyer er bebodd, og tilfeldig hvilken av disse\r\n  #AntallBebodd = sample(1:nØyer,1)\r\n  AntallBebodd = ParameterSpace$RangeStartProp[i]*nØyer #i\r\n  Bebodd = sample(1:nØyer,AntallBebodd)\r\n  \r\n  Tilstede = rep(0, nØyer)\r\n  Tilstede[Bebodd]<-1\r\n  TidsserieTilstede = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\n  TidsserieTilstede[1,]<-Tilstede\r\n  \r\n  TidsserieKoloniseringsrater = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\n  TidsserieKoloniseringsrater[1,]<-0\r\n  \r\n  # tilfeldig plassering av øyene\r\n  ArenaStørrelse = ParameterSpace$RangeLandskap[i]\r\n  xPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  yPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  # Tilfeldig størrelse\r\n  ØyStr = rlnorm(n = nØyer, meanlog = .1, sdlog = .1) #Ai\r\n  \r\n  # Regn ut mellom-øy avstand\r\n  MellomØyAvstand = dist(cbind(xPos, yPos), diag = T, upper = T) # dij\r\n  Alpha = -1#1/mean(MellomØyAvstand)\r\n  \r\n  # Konstanter\r\n  c_konstant = ParameterSpace$RangeKonstantC[i]\r\n  e_konstant = ParameterSpace$RangeKonstantE[i]\r\n  \r\n  # Utryddelsesrater er konstant over tid\r\n  UtryddelsesRateØy_i = e_konstant/ØyStr\r\n  \r\n  # fra Hanski, Ilkka, et al. \"The quantitative incidence function model and persistence of an endangered butterfly metapopulation.\" Conservation Biology 10.2 (1996): 578-590.\r\n  ØystrEffekt = 0.952\r\n  muTick = 0.158\r\n  \r\n  AjAi = sapply(ØyStr, function(x) x*ØyStr)\r\n  mij = exp(-Alpha*as.matrix(MellomØyAvstand))*AjAi # number of immigrants\r\n \r\n  # Tidssteg \r\n  t = 2\r\n  \r\n  while(t< ){\r\n    KoloniseringsRateØy_i = sapply(1:nØyer, function(i){\r\n      c_konstant*sum(Tilstede[-i]*ØyStr[-i]*\r\n                       exp(-Alpha*as.matrix(MellomØyAvstand)[-i,i]))}) # Si\r\n    \r\n    TidsserieKoloniseringsrater[t,]<-KoloniseringsRateØy_i\r\n    \r\n    # Sannsynligheten for bebodd øy\r\n    Pi = KoloniseringsRateØy_i/(KoloniseringsRateØy_i + UtryddelsesRateØy_i) # Også kjent som Ji\r\n    #Pi = 1/(1+(muTick/(KoloniseringsRateØy_i*ØyStr^ØystrEffekt)))\r\n    Kolonisert = sapply(Pi, function(x) sample(0:1, 1, prob = c(1-x,x)))\r\n    \r\n    # Oppdater bebodd-status\r\n    Tilstede<-Kolonisert\r\n    TidsserieTilstede[t,]<-Tilstede\r\n    # Oppdater tidssteg\r\n    t = t+1\r\n  }\r\n  \r\n  \r\n  \r\n  ParameterSpace$SnittPrevalens[i] = median(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$SdPrevalens[i] = sd(rowMeans(TidsserieTilstede), na.rm = T)\r\n}\r\n\r\n# library(ggplot2);library(ggExtra);library(gridExtra)\r\np1 = ggplot()+\r\n  geom_point(mapping = aes(x = xPos, y = yPos, size = ØyStr), pch = 21, show.legend = FALSE)+\r\n  ggtitle(paste(\"Utgangstetthet:\", mean(TidsserieTilstede[1,])))\r\np2 = ggplot()+\r\n  geom_line(mapping = aes(x = 1:tmax, y = rowMeans(TidsserieTilstede)))+\r\n ylab(\"Andel bebodde\") + ylab(\"Tidssteg\")\r\ngrid.arrange(p1, p2, nrow = 2)\r\n\r\nFor pedagogikkens skyld så viser vi i figur 4 et system av habitat med nogenlunde stabile dynamikker, men dette er som sagt ikke alltid tilfelle.\r\n\r\n\r\nShow code\r\n\r\nlibrary(ggplot2);library(ggExtra);library(data.table)\r\n\r\n# Antall øyer/habitat i systemet\r\nnØyer = 40 #i\r\n\r\n# lengde på tidsserie\r\ntmax = 500\r\n\r\n# Sett et frø for utgangspunkt\r\n#set.seed(999)\r\n# Tilfeldig antall øyer er bebodd, og tilfeldig hvilken av disse\r\n#AntallBebodd = sample(1:nØyer,1)\r\nAntallBebodd = ceiling(nØyer*.2)\r\nBebodd = sample(1:nØyer,AntallBebodd)\r\n\r\nTilstede = rep(0, nØyer)\r\nTilstede[Bebodd]<-1\r\nTidsserieTilstede = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\nTidsserieTilstede[1,]<-Tilstede\r\n\r\nTidsserieKoloniseringsrater = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\nTidsserieKoloniseringsrater[1,]<-0\r\n\r\n\r\n# tilfeldig plassering av øyene\r\nArenaStørrelse = 3.4\r\nxPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\nyPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n# Tilfeldig størrelse\r\nØyStr = rlnorm(n = nØyer, meanlog = .1, sdlog = .1) #Ai\r\n# Ovaskainen 2003 brukes snitt = 1, og sd = 4\r\n\r\n# Regn ut mellom-øy avstand\r\nMellomØyAvstand = dist(cbind(xPos, yPos), diag = T, upper = T) # dij\r\nAlpha = -1#1/mean(MellomØyAvstand)\r\n\r\n# Konstanter\r\nc_konstant = .6\r\ne_konstant = 87\r\n\r\n\r\n# l_ex = 0.8;l_em = .5; l_im = 0.5\r\n# Utryddelsesrater er konstant over tid\r\nUtryddelsesRateØy_i = e_konstant/ØyStr\r\n\r\n# fra Hanski, Ilkka, et al. \"The quantitative incidence function model and persistence of an endangered butterfly metapopulation.\" Conservation Biology 10.2 (1996): 578-590.\r\nØystrEffekt = 0.952\r\nmuTick = 0.158\r\n\r\nAjAi = sapply(ØyStr, function(x) x*ØyStr)\r\nmij = exp(-Alpha*as.matrix(MellomØyAvstand))*AjAi # number of immigrants\r\n#print(eigen(mij)$values[1])\r\n\r\n# Tidssteg \r\nt = 2\r\n\r\nwhile(t<tmax){\r\n  KoloniseringsRateØy_i = sapply(1:nØyer, function(i){\r\n    c_konstant*sum(Tilstede[-i]*ØyStr[-i]*\r\n                     exp(-Alpha*as.matrix(MellomØyAvstand)[-i,i]))\r\n  }) # Si\r\n  \r\n  TidsserieKoloniseringsrater[t,]<-KoloniseringsRateØy_i\r\n  \r\n  # Sannsynligheten for bebodd øy\r\n  Pi = KoloniseringsRateØy_i/(KoloniseringsRateØy_i + UtryddelsesRateØy_i) # Også kjent som Ji\r\n  #Pi = 1/(1+(muTick/(KoloniseringsRateØy_i*ØyStr^ØystrEffekt)))\r\n  Kolonisert = sapply(Pi, function(x) sample(0:1, 1, prob = c(1-x,x)))\r\n  \r\n  # Oppdater bebodd-status\r\n  Tilstede<-Kolonisert\r\n  TidsserieTilstede[t,]<-Tilstede\r\n  # Oppdater tidssteg\r\n  t = t+1\r\n}\r\n\r\n\r\nlibrary(ggplot2);library(ggExtra);library(gridExtra)\r\np1 = ggplot()+xlab(\"Koordinat x\")+ylab(\"Koordinat y\")+\r\n  geom_point(mapping = aes(x = xPos, y = yPos, fill = colMeans(TidsserieTilstede, na.rm = T), size = ØyStr), pch = 21, show.legend = F)+theme_cowplot()\r\np2 = ggplot()+\r\n  geom_line(mapping = aes(x = 1:tmax, y = rowMeans(TidsserieTilstede)))+\r\n  ylab(\"Andel bebodde habitat\")+xlab(\"Tidssteg\")+theme_cowplot()\r\ngrid.arrange(p1, p2, nrow = 3, \r\n             layout_matrix = cbind(c(1,1,1,1,2,2), c(1,1,1,1,2,2)))\r\n\r\n\r\n\r\nFigure 4: Populasjonene er spredt utover landskapet, og migrasjonen mellom de er avengig av arealet og avstanden til populasjonene rundt. Trykk Show code over for parameterverdier for simuleringen.\r\n\r\n\r\n\r\nMetapopuasjonsteori er blitt brukt til å finne ut hvordan bestander av sommerfuglen prikkrutevinge (Melitaea cinxia) på øyene i Åland svinger fra år til år (Hanski et al. (1996)). Her beveger den seg mellom øyer og mellom de tørre blomsterengene som den trives i.\r\nI gode og onde dager\r\nI den virkelige verden finnes det også gode og dårlige år. Slike tilfeldigheter (som skjer innenfor et visst omfang) kalles miljøstokastisitet. Miljøstokastisitet rammer alle bestander like mye - store bestander vil riktignok kunne tåle det bedre enn mindre bestander.\r\nHabitatstørrelsen \\(A_{j}\\) i forrige del kan også tolkes som habitatkvalitet. Gode og dårlige år kan derfor simuleres ved å lage en normalfordeling rundt 0 hvor en trekker en verdi for hvert år, som så legges til alle habitatstørrelser. Gode år vil være positive verdier og øke habitatstørrelsen, mens dårlige år vil være negative verdier som reduserer habitatstørrelsen. Økende stokastisitet vil tilsi at en øker variansen på normalfordelingen man trekker ifra. Økende varians betyr at en vil få enda bedre gode år, men tilsvarende også enda verre dårlige år (figur 5).\r\nPå lang sikt har stokastisitet som regel negative konsekvenser for den langsiktig veksten for bestander. Og ja, klimaendringer med økende frekvens av ekstremvær betyr at det vil bli mer stokastisitet. Økende stokastisitet kan føre til at bestander går fra å være i vekst til å være i nedgang (figur 5).\r\n\r\n\r\nShow code\r\n\r\nlibrary(data.table)\r\nnSimulations = 100\r\nParameterSpace = expand.grid(nIterations = 1:nSimulations,\r\n                             #RangeØyer = seq(40,60,length.out = 1),\r\n                             RangeStartProp = seq(.35,.6,length.out = 1),\r\n                             RangeLandskap = seq(3.4,3.7,length.out = 1),\r\n                             RangeKonstantC = seq(.24,.75,length.out =  1),# .23->.24\r\n                             RangeKonstantE = seq(150,100,length.out = 1),# 60->120\r\n                             eNoise = seq(0,3,length.out = 4))\r\nsetorder(ParameterSpace, nIterations)\r\n\r\nParameterSpace$SnittPrevalens = NA\r\nParameterSpace$SdPrevalens = NA\r\nParameterSpace$MinPrevalens = NA\r\nParameterSpace$AndelUtvikling = NA\r\niteration = 0\r\n\r\nRangeØyer = 40\r\nnØyer = RangeØyer # ParameterSpace$RangeØyer[i] #i\r\n\r\nTidsArray = array(rep(0, tmax*nØyer), \r\n                  dim = c(tmax, nØyer,  nrow(ParameterSpace)))\r\n\r\nTidsserieKoloniseringsrater = array(rep(0, tmax*nØyer), \r\n                                    dim = c(tmax, nØyer, nrow(ParameterSpace)))\r\n\r\nGeografiArray = array(rep(NA, 3*nØyer),\r\n                      dim = c(3, nØyer, nrow(ParameterSpace)))\r\n\r\n\r\nfor(i in 1:nrow(ParameterSpace)){\r\n  #print(paste(i , \"av\", nrow(ParameterSpace)))\r\n  # Antall øyer/habitat i systemet\r\n  \r\n  # lengde på tidsserie\r\n  tmax = 100\r\n  \r\n  iteration <- ParameterSpace$nIterations[i]\r\n  \r\n  AntallBebodd = ParameterSpace$RangeStartProp[i]*nØyer #i\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  Bebodd = sample(1:nØyer,AntallBebodd)\r\n  \r\n  \r\n  Tilstede = rep(0, nØyer)\r\n  Tilstede[Bebodd]<-1\r\n  \r\n  TidsserieTilstede = matrix(rep(rep(NA, nØyer), tmax), ncol = nØyer)\r\n  TidsserieTilstede[1,]<-Tilstede\r\n  \r\n  TidsArray[1,,iteration]<-Tilstede\r\n  TidsserieKoloniseringsrater[1,,iteration]<-Tilstede\r\n  \r\n  # tilfeldig plassering av øyene\r\n  ArenaStørrelse = ParameterSpace$RangeLandskap[i]\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  xPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  set.seed(-iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  yPos = runif(n = nØyer, min = 0, max = ArenaStørrelse)\r\n  \r\n  # Tilfeldig størrelse\r\n  set.seed(iteration) # slik at ulike miljøstøy-nivå vil testes på de samme øy-konfigurasjonene\r\n  ØyStr = rlnorm(n = nØyer, meanlog = .1, sdlog = .2) #Ai\r\n  \r\n  GeografiArray[,,i]<-rbind(ØyStr, xPos, yPos)\r\n  # Regn ut mellom-øy avstand\r\n  MellomØyAvstand = dist(cbind(xPos, yPos), diag = T, upper = T) # dij\r\n  Alpha = -1#1/mean(MellomØyAvstand)\r\n  \r\n  # Konstanter\r\n  c_konstant = ParameterSpace$RangeKonstantC[i]\r\n  e_konstant = ParameterSpace$RangeKonstantE[i]\r\n  \r\n  eNoise = ParameterSpace$eNoise[i]\r\n  # Utryddelsesrater er konstant over tid\r\n  UtryddelsesRateØy_i = e_konstant/ØyStr\r\n  \r\n  # fra Hanski, Ilkka, et al. \"The quantitative incidence function model and persistence of an endangered butterfly metapopulation.\" Conservation Biology 10.2 (1996): 578-590.\r\n  # ØystrEffekt = 0.952\r\n  # muTick = 0.158\r\n  \r\n  # AjAi = sapply(ØyStr, function(x) x*ØyStr)\r\n  # mij = exp(-Alpha*as.matrix(MellomØyAvstand))*AjAi # number of immigrants\r\n  \r\n  # Tidssteg \r\n  t = 2\r\n  NoiseE = rnorm(n = tmax, sd = eNoise)\r\n  while(t<tmax){\r\n    \r\n    KoloniseringsRateØy_i = sapply(1:nØyer, function(i){\r\n      Aj = ØyStr[-i]\r\n      Aj = Aj +NoiseE\r\n      c_konstant*sum(Tilstede[-i]*Aj*\r\n                       exp(-Alpha*as.matrix(MellomØyAvstand)[-i,i]))}) # Si\r\n    \r\n    \r\n    TidsserieKoloniseringsrater[t,,i]<-KoloniseringsRateØy_i\r\n    \r\n    \r\n    # Sannsynligheten for bebodd øy\r\n    Pi = KoloniseringsRateØy_i/(KoloniseringsRateØy_i + UtryddelsesRateØy_i) # Også kjent som Ji\r\n    Pi = ifelse(Pi>1,1,ifelse(Pi<0,0,Pi))\r\n    \r\n    Kolonisert = sapply(Pi, function(x) sample(0:1, 1, prob = c(1-x,x)))\r\n    \r\n    # Oppdater bebodd-status\r\n    Tilstede<-Kolonisert\r\n    TidsserieTilstede[t,]<-Tilstede\r\n    TidsArray[t,,i]<-Tilstede\r\n    \r\n    # Oppdater tidssteg\r\n    t = t+1\r\n  }\r\n  \r\n  ParameterSpace$SnittPrevalens[i] = median(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$SdPrevalens[i] = sd(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$MinPrevalens[i] = min(rowMeans(TidsserieTilstede), na.rm = T)\r\n  ParameterSpace$AndelUtvikling[i] = coef(lm(rowMeans(TidsserieTilstede)~I(1:length(rowMeans(TidsserieTilstede)))))[2]\r\n  if(i==nrow(ParameterSpace)){\r\n    saveRDS(list(ParameterSpace = ParameterSpace,\r\n             Geografi = GeografiArray,\r\n             TidsArray = TidsArray,\r\n             TidsserieKoloniseringsrater = TidsserieKoloniseringsrater),\r\n        \"ParameterSpace_MetaPopStoch.rds\")\r\n  }\r\n}\r\n\r\nlibrary(ggplot2);library(cowplot);library(scales);library(gridExtra)\r\np1 = ggplot(data = ParameterSpace, aes(y = MinPrevalens, x = eNoise, group = factor(eNoise)))+geom_boxplot()+theme_cowplot()+\r\n  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+ylab(\"Andel\\n(minimum)\")\r\np2 = ggplot(data = ParameterSpace, aes(y = SnittPrevalens, x = eNoise, group = factor(eNoise)))+geom_boxplot()+theme_cowplot()+\r\n  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+ylab(\"Andel\\n(gj.snitt)\")\r\n\r\np3 = ggplot(data = ParameterSpace, aes(y = AndelUtvikling*200, x = eNoise, group = factor(eNoise)))+geom_hline(yintercept = 0, linetype=\"dashed\")+theme_cowplot()+\r\n  geom_boxplot()+ylab(\"Vekst \\n (andel endring per år x 200)\") + xlab(\"Miljøstokastisitet\")#+\r\n#scale_y_continuous(breaks = seq(-.2,.2,.1))+coord_cartesian(ylim = c(-0.1,0.1))\r\n\r\ngrid.arrange(p1,p2,p3)\r\n\r\n\r\n\r\nFigure 5: Stokastisitet reduserer minimum og gjennomsnittlige andelen av habitat som over tid har en bestand, og kan forårsake negativ veksten i bebodde habitat. Den negative veksten vil til slutt føre til at metapopulasjonen vil dø ut.\r\n\r\n\r\n\r\nMen hvilke habitat er viktige? Og hva kan vi gjøre for å styrke metapopulasjonen? Det er spørsmålet får vi gyve løs på senere.\r\n\r\n\r\n\r\nHanski, Ilkka. 1994. “A Practical Model of Metapopulation Dynamics.” Journal of Animal Ecology, 151–62.\r\n\r\n\r\nHanski, Ilkka, Atte Moilanen, Timo Pakkala, and Mikko Kuussaari. 1996. “The Quantitative Incidence Function Model and Persistence of an Endangered Butterfly Metapopulation.” Conservation Biology 10 (2): 578–90.\r\n\r\n\r\nHanski, Ilkka, and Otso Ovaskainen. 2000. “The Metapopulation Capacity of a Fragmented Landscape.” Nature 404 (6779): 755–58.\r\n\r\n\r\nLevin, Simon A. 1970. “Community Equilibria and Stability, and an Extension of the Competitive Exclusion Principle.” The American Naturalist 104 (939): 413–23.\r\n\r\n\r\nLevins, Richard. 1969. “Some Demographic and Genetic Consequences of Environmental Heterogeneity for Biological Control.” American Entomologist 15 (3): 237–40.\r\n\r\n\r\nMacArthur, Robert H, and Edward O Wilson. 2016. The Theory of Island Biogeography. Princeton university press.\r\n\r\n\r\nSimberloff, Daniel S, and Edward O Wilson. 1970. “Experimental Zoogeography of Islands. A Two-Year Record of Colonization.” Ecology 51 (5): 934–37.\r\n\r\n\r\nVi antar stort antall øyer, og at Allee-effekten er neglisjerbar og ser bort fra \\(y^2\\), Hanski (1994)↩︎\r\n",
    "preview": "posts/Metapopulasjoner/Blog_metapopulasjoner_files/figure-html5/FIG0-1.png",
    "last_modified": "2022-10-16T15:38:16+02:00",
    "input_file": {}
  },
  {
    "path": "posts/Nisje/",
    "title": "Nisje: Location, location, location",
    "description": "Og hvor er min plass i dette n-dimensjonale hypervolumet?",
    "author": [
      {
        "name": "Endre Grüner Ofstad",
        "url": {}
      }
    ],
    "date": "2022-01-03",
    "categories": [
      "Økologi",
      "Økosystem"
    ],
    "contents": "\r\nNisje\r\nFolk flest vet sånn noenlunde hva ordet nisje betyr. Innefor økologi skiller man mellom fundamendal nisje og realisert nisje. Fundamental nisje er den kombinasjoen av miljøvariabler som tillater en art å overleve. Veldig ofte vil temperatur være en viktig milljøvariabel. Det må som regel være passe varmt. Ikke for kaldt, men samtidig ikke for varmt. Videre så må det kanskje være tilgang på den og den andre typen mat, sommeren må være passe lang, og vinteren må innebære hvertfall en halv meter snø som ligger mer enn 3 måneder og bakken kan ikke ha for mye kalk i seg. Slik at i møte med omgivelsene (dvs. flere miljøvariabler) vil en art bare forekomme på de plassene som innfrir alle disse kravene (figur 1).\r\nHver slik miljøvariabel kan kalles for en dimensjon. I figur 1 og 2 utvider vi miljøet fra en til tre miljøvariabler - dimensjoner - og kan slikt fortsette å utvide det så langt som nødvendig. Til vi ender opp med et n-dimensjonalt hypervolum (Hutchinson (1958)), i 2 har vi n=3, et 3-dimensjonalt hypervolum. I virkeligheten vil det ofte være betraktelig flere dimensjoner som arter responderer på.\r\nTo arter kan ikke ha nisjer som fullstendig overlapper med hverandre, da vil en av de bli utryddet. Dette er kjent som som Gauss regel eller Gauss konkurranseekskluderingsprinsipp1. I møte med flere arter vil det derfor oppstå interaksjoner mellom artene som kan utvide eller begrense nisjen til en art (figur 1 og 2). En snakker da om den realiserte nisjen til en art.\r\n\r\n\r\nShow code\r\n\r\n# in 2d \r\nlibrary(plyr)\r\nlibrary(ggplot2)\r\nlibrary(mgcv)\r\nlibrary(depth)\r\nlibrary(plyr)\r\nlibrary(ggplot2)\r\nlibrary(rgl)\r\nlibrary(geometry)\r\nlibrary(gridExtra)\r\nlibrary(cowplot)\r\n\r\n\r\ndata(iris)\r\ndf=iris[,c(1,2,5)]\r\ndf$Species = factor(df$Species, labels = c(\"Art 1\", \"Art 2\", \"Art 3\"))\r\nnames(df)<-c(\"Miljø 1\", \"Miljø 2\", \"Art\")\r\n\r\np1 = ggplot(data = df, mapping = aes(x = `Miljø 1`, fill = Art))+geom_histogram(show.legend = F, bins = 10)+ylab(\"Antall\")+\r\n  theme_half_open() +\r\n  background_grid()\r\n\r\nalph=0.05\r\nfind_bag = function(x,alpha=alph) {\r\n  n=nrow(x)\r\n  propinside=1\r\n  target=1-alpha\r\n  x2=x\r\n  while (propinside>target) {\r\n    propinside=nrow(x2)/n\r\n    hull=chull(x2)\r\n    x2old=x2\r\n    x2=x2[-hull,]\r\n  }\r\n  x2old[chull(x2old),] }\r\nbags <- ddply(df, \"Art\", find_bag, alpha=alph)\r\np2 <- ggplot(data = df, aes(x = `Miljø 1`, y = `Miljø 2`, colour=Art, fill = Art)) +\r\n  geom_point(size = 2) +\r\n  geom_polygon(data = bags, alpha = 0.5) +\r\n  labs(x = \"Miljø 1\", y = \"Miljø 2\")+\r\n  theme_half_open() +\r\n  background_grid()+\r\n  theme(legend.position=\"bottom\",\r\n        legend.title = element_blank(),\r\n        legend.box.just = \"center\")\r\ngrid.arrange(p1, p2, nrow = 3, \r\n             layout_matrix = cbind(c(1,1,2,2,2,2,2,2), c(1,1,2,2,2,2,2,2)))\r\n\r\n\r\n\r\n\r\nFigure 1: En art finnes ikke overalt, bare hvor den kan overleve og reprodusere.\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\noptions(rgl.useNULL = TRUE) # Suppress the separate window.\r\nlibrary(rgl)\r\n\r\ndata(iris)\r\ndf=iris[,c(1,2,3,5)]\r\nnames(df)<-c(\"Miljø 1\", \"Miljø 2\", \"Miljø 3\", \"Art\")\r\nlevels=unique(df[,\"Art\"])\r\nnlevels=length(levels)\r\nzoom=0.8\r\ncex=1\r\naspectr=c(1,1,0.7)\r\npointsalpha=1\r\nuserMatrix=matrix(c(0.80,-0.60,0.022,0,0.23,0.34,0.91,0,-0.55,-0.72,0.41,0,0,0,0,1),ncol=4,byrow=T)\r\nwindowRect=c(0,29,1920,1032)\r\ncols=c(\"red\",\"forestgreen\",\"blue\")\r\nalph=0.05\r\n\r\nplotbag = function(x,alpha=alph,grp=1,cols=c(\"red\",\"forestgreen\",\"blue\"),transp=0.2) {\r\n  propinside=1\r\n  target=1-alpha\r\n  x2=x\r\n  levels=unique(x2[,ncol(x2)])\r\n  x2=x2[x2[,ncol(x2)]==levels[[grp]],]\r\n  n=nrow(x2)\r\n  while (propinside>target) {\r\n    propinside=nrow(x2)/n\r\n    hull=unique(as.vector(convhulln(as.matrix(x2[,1:3]), options = \"Tv\")))\r\n    x2old=x2\r\n    x2=x2[-hull,]\r\n  }\r\n  ids=t(convhulln(as.matrix(x2old[,1:3]), options = \"Tv\"))\r\n  rgl.triangles(x2old[ids,1],x2old[ids,2],x2old[ids,3],col=cols[[grp]],alpha=transp,shininess=50)\r\n}\r\ninvisible(open3d(zoom=zoom,userMatrix=userMatrix,windowRect=windowRect,antialias=8)\r\n)\r\nfor (i in 1:nlevels) { \r\n  plot3d(x=df[df[,ncol(df)]==levels[[i]],][,1],\r\n         y=df[df[,ncol(df)]==levels[[i]],][,2],\r\n         z=df[df[,ncol(df)]==levels[[i]],][,3],\r\n         type=\"s\", \r\n         col=cols[[i]],\r\n         size=cex,\r\n         lit=TRUE,\r\n         alpha=pointsalpha,point_antialias=TRUE,\r\n         line_antialias=TRUE,shininess=50, add=TRUE)\r\nplotbag(df,alpha=alph, grp=i, cols=c(\"red\",\"forestgreen\",\"blue\"), transp=0.3) }\r\naxes3d(color=\"black\",drawfront=T,box=T,alpha=1)\r\ntitle3d(color=\"black\",xlab=\"Miljo 1\",ylab=\"Miljo 2\", zlab=\"Miljo 3\",alpha=1)\r\naspect3d(aspectr)\r\n\r\nrglwidget()\r\n\r\n\r\n\r\n\r\n\r\nFigure 2: En art finnes ikke overalt, bare hvor den kan overleve og reprodusere.\r\n\r\n\r\n\r\n(I figur 1 og 2 viser vi ekte data for lilje-artene Iris setosa, Iris virginica og Iris versicolor. Miljøvariablene er riktignok lengden og bredden av begerbladet, og bredden av kronebladet til disse artene. )\r\nBiotop er når en utvider habitatkonseptet til flere arter (Whittaker, Levin, and Root (1973)). Hvor art 1 og 2 i figur 2 sammen med den det miljøet de befinner seg i en biotop. Dette er et system som også går igjen i naturtype-systemet i Norge: Natur i Norge (NiN). Hvor såkalte lokale komplekse miljøvariabler (forferdelig lite pedagogisk navn) tilsvarer en miljøvariabel som for eksempel kalkinnhold. Her vil f.eks. fastmarksskogsmark bli kalt for et hovedtypegruppe (også kalt for et økosystem i Halvorsen et al. (2020)), men en skog med gitt kalkinnhold og uttørkingsfare kan være kalklågurt-skog. Kalklågurt-skog kalles for en naturtype, men er og en biotop da den karakteriseres av de artene man finner innenfor gitte miljøparametre.\r\nHvorfor starter og slutter nisjen?\r\nDet meste i livet består av avveininger. Som nevnt over så er det viktig at det er passe varmt. Er det for kaldt så vil ikke kroppen kunne lage nok varme og vi vil fryse i hjel, og ved for varmt vil ikke kroppen kunne kjøle seg nok ned og en vil dø av overoppheting. I noen tilfeller kan avveiningen også skje på grunn av samspill med andre arter, eller fordelene kan inntreffe på en del av livet og kostnadene i en annen del. For en rekke arter vil det være gunstig å bruke visse deler av habitatet fordi der er det mye bra mat tilgjengelig som igjen fører til at de kan vokse seg store, få unger og fø opp disse. Men dette er jo også noe rovdyrene lærer slik at å tilbringe for mye tid der kan innebære en økt sannsynlighet for å bli spist. Så hvor mye tid skal man tilbringe der?\r\nFor at en art skal overleve må det være nok reproduksjon og overlevelse til at en på lang sikt minimum går i null. Dette kan igjen knyttes til miljøet. Hvis en følger eksempelet over for art 1. La oss si at jo mer du øker miljøvariabel 1 dess flere avkom får du, men det reduserer hvor lenge du vil leve. På en årlig basis så kan en si at en øker sannsynligheten for å få et avkom, men en reduserer sannsynligheten for at du overlever til neste år. Over tid vil disse to faktorene - overlevelse og reproduksjon - bestemmer hvor mange avkom ett individ vil få iløpet av livet (lifetime reproductive success). Den optimale strategien (nytte hvis man bruker ressursøkonomiske begreper) kan vi da finne ved å se på ved å multiplisere disse to funksjonene med hverandre (figur 3). Dette kommer også frem av denne studien (snikskryt). I figur 1 og 2 så er ikke alle punktene/forekomstene innenfor den fargede “konvolutten.” Dette kan tolkes som at selv om en art befinner seg i et område så kan det være at det området ikke er “bra nok” slik at overlevelse og reproduksjon er for lav til at man klarer seg der på lang sikt. Området er derfor ikke nødvendigvis en del av arten sitt habitat, selv om arten er observert der.\r\n\r\n\r\nShow code\r\n\r\nlibrary(boot)\r\npar(mfrow = c(1,3), bty = \"L\", omi = c(0,0,0,0), mar = c(4,5,0,0))\r\ncurve(inv.logit(2+.35*x), from = -2, to = 2, ylim = c(0,1), col = \"blue\", xlab = \"Miljøvariabel 1\",\r\n      ylab = \"Fordel/Ulempe\", lwd = 2, cex.lab = 2.2, cex.axis = 1.7)\r\nabline(v = 0, lty = \"dashed\")\r\ncurve(inv.logit(.25-2.5*x), from = -2, to = 2, add = T, col = \"red\", lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\ncurve((inv.logit(2+.35*x)*inv.logit(.25-2.5*x)), col = \"green\", add = T, lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\n\r\ncurve(inv.logit(.25+3.35*x), from = -2, to = 2, col = \"blue\", xlab = \"Miljøvariabel 2\",\r\n      ylab = \"Fordel/Ulempe\", lwd = 2, cex.lab = 2.2, cex.axis = 1.7)\r\nabline(v = 0, lty = \"dashed\")\r\ncurve(inv.logit(.25+-4.5*x), from = -2, to = 2, add = T, col = \"red\", lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\ncurve((inv.logit(.25+-4.5*x)*inv.logit(.25+3.35*x)), col = \"green\", add = T, lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\n\r\n\r\ncurve(inv.logit(.25+3.35*x), from = -2, to = 2,  col = \"blue\", xlab = \"Miljøvariabel 3\",\r\n      ylab = \"Fordel/Ulempe\", lwd = 2, cex.lab = 2.2, cex.axis = 1.7)\r\nabline(v = 0, lty = \"dashed\")\r\ncurve(inv.logit(.15-.5*x), from = -2, to = 2, add = T, col = \"red\", lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\ncurve((inv.logit(.25+3.35*x)*inv.logit(.15-.5*x)), col = \"green\", add = T, lwd = 2, cex.lab = 1.7, cex.axis = 1.3)\r\n\r\n\r\n\r\n\r\nFigure 3: Fordel (blå), ulempe (rød) og nytte (grønn) knyttet til bruken av ulike miljøvariabler. Nisjen vil da være det området hvor nytten er større enn null, dvs. hvor både overlevelse og reproduksjon er positiv på lang sikt.\r\n\r\n\r\n\r\nShow code\r\n\r\n#legend(\"bottomright\", c(\"Fordel\", \"Ulempe\",\"Nytte\"), c(\"blue\", \"red\", \"green\"), lwd = 2)\r\n\r\n\r\n\r\nDen største trusselen mot arter i Norge er habitatendringer - det være seg tap eller forringing av habitat. Ved forvaltningsavgjørelser kan en ofte bli møtt av påstanden “Men den arten finnes jo også der og der, så vi kan bygge ned her.” Når her er den plassen det finnes mest av en art så er det en grunn til det.\r\nSelv om en art kan bruke to områder så vil det som regel velge et alternativ fremfor det andre. Det ble tidlig anerkjent at områder en art kan velge blant sjelden ble brukt i den grad de var tilgjengelig, noen områder ble brukt forholdsmessig ofte: “[dyret] spiser ved et tydelig valg” (Hardy (1924)). Når områdebruken ikke er proporsjonal med tilgjengeligheten sier man at bruken er selektiv og at det foregår habitatvalg (habitat selection, Johnson (1980)). Valg skjer enten ved at man tilbringer lengre tid eller vender oftere tilbake til områder med høyere nytte (Bastille-Rousseau, Fortin, and Dussault (2010)). Dette reflektere at et område har 1) økt energiopptak per mat-gjenstand, men også 2) mindre tid på å fordøye hver mat-gjenstand (MacArthur and Pianka (1966)). Valg av føde kan derfor føre til både mer og bedre mat, og en multiplikativ økning i energiopptaket (multiplier effect, white1983foraging). Hos dyr ser man at valg, fremfor mer tilfeldig bruk, av habitat er assosiert med økt overlevelse og reproduksjon (Allen et al. (2017), McLoughlin et al. (2006), Losier et al. (2015)).\r\nHvor starter og slutter en nisje?\r\nHvor starter og slutter nisjen til en art? Grovt sett vil den jo finnes i det området hvor den kan overleve og reprodusere, jf. arealet under den grønne linjen i figur 3. Men muligheten til å kunne tallfeste dette kan fortelle oss hvor vi kan finne skadedyr, høstbare arter, eller sjeldne arter. Slik at dette er et viktig tema som har fått mye oppmerksom siden 1990-tallet og frem til idag. Habitatseleksjon gjør at vi kan knytte ulike habitat og områder til arter sin reproduksjon og overlevelse (Boyce and McDonald (1999)). For eksempel kan to hjorter tilbringe 40 % av tiden sin i løvskog (bruken kalles ofte U[x], use distribution), men en hjort holder til i et områder med 30 % tilgjengelig løvskog, mens den andre i et området med 40 % tilgjenglig løvskog (kjent som A[x], availability distribution). Å sammenligne bruken deres vil derfor ikke reflektere i hvor stor grad dyret vil velge løvskog når det har muligheten til det. Hvis man ser på graden av valg (‘selection ratio’/SR) vil vise at det første dyret vil i mindre grad velge løvskog enn det andre dyret (SR[x] = U[x]/A[x]; 40/30 = 1.33 vs 40/10 = 4.00).\r\nKarakterisering av nisje kan gjøres på mange måter. I systemet nevnt over, Natur i Norge (NiN) så bruker man ordinasjonsteknikker. Man kan lese mer om dette i Halvorsen et al. (2020). Dette har mye til felles med en rekke andre statistiske metoder som alle faller inn under paraply-begrepet inhomogene Poisson-prosesser. Hvor man ganske enkelt sammenligner med tilstedeværelse (eller antall) og fravær av arter/individ i ulike miljø. Den interesserte leser anbefales sterkt å fordype seg i Aarts et al. (2013), Aarts, Fieberg, and Matthiopoulos (2012) og Lele et al. (2013).\r\nNår tilgjengeligheten av habitat forandrer seg\r\nNår tilgjengeligheten av habitat forandrer seg så kan også nytten av å bruke den forandre seg, og derfor også habitatvalget. En snakker om en funksjonell respons i habitatvalg (Mysterud and Ims (1998)). Funksjonell respons kan skyldes avveininger mellom ulike atferder (Beyer et al. (2010)), fysiologiske begrensninger (Melin et al. (2014)), eller variere med hvordan dyr oppfatter habitatene de velger blant (Van Moorter et al. (2013)). For eksempel vil hjortedyr ofte velge åpne enger eller åkre ved lav tilgjengelighet, men redusere valget av det med økende tilgjengelighet. Dette kan f.eks. skyldes at å velge åpne enger hele tiden vil innebære en for stor risiko for rovdyr, eller at de må ha en mer balansert diet som også inkluderer annen føde.\r\nLavere tilgjengelighet av habitat innebærer som regel lengre avstand mellom habitat, som spising må kompensere for. Dess lengre man må forflytte seg mellom habitat, jo mer må habitatet utnyttes for å kompensere for bevegelseskostnadene (‘marginal value theorem,’ Charnov (1976)). Dette innebærer at ikke bare tilgjengeligheten i seg selv, men også hvordan den er fordelt i landskapet påvirker kost-nytten ved habitatvalg. Avslutningsvis vil også tilgjengeligheten være avhengig av bestandstettheten. Med økende tetthet vil en forvente at nytten av å bruke et habitat vil bli mindre (‘ideal free distribution,’ Fretwell and Lucas (1969), Morris (1987))\r\nLocation, location, location\r\nAlt er en plass. Dyr har en preferanse for noen habitat som de velger, men de må også komme seg til de habitatene. Johnson (1980) beskriver habitatvalg som hierarki av valg på ulike skalaer. Første-ordens er valg av artens geografiske utbredelse; andre-ordens valget er individets valg av hjemmeområde; tredje-ordens valget er habitatvalget innad i hjemmeområdet; og det fjerde-ordens valget er valget av matgjenstander (den busken, det skjellet osv.). De ulike romlige skalene vil også ha reflektere tidsskalaen ; snaker man om habitatvalg over et helt liv? Ett år? Ett døgn? Forskjeller i habitatvalg på ulike skala reflektere avveininger mellom ulike livshistorietrekk. Rettie and Messier (2000) har foreslått at individ tilpasser seg de miljøvariablene som begrenser overlevelse og reproduksjon mest på de større skalaene (første- eller andre-ordens valg), slik at konsekvensene av habitatvalg for overlevelse og reproduksjon blir mindre og mindre jo lavere skale en ser på.\r\n\r\n\r\n\r\nAarts, Geert, John Fieberg, Sophie Brasseur, and Jason Matthiopoulos. 2013. “Quantifying the Effect of Habitat Availability on Species Distributions.” Journal of Animal Ecology 82 (6): 1135–45.\r\n\r\n\r\nAarts, Geert, John Fieberg, and Jason Matthiopoulos. 2012. “Comparative Interpretation of Count, Presence–Absence and Point Methods for Species Distribution Models.” Methods in Ecology and Evolution 3 (1): 177–87.\r\n\r\n\r\nAllen, Andrew M, Augusta Dorey, Jonas Malmsten, Lars Edenius, Göran Ericsson, and Navinder J Singh. 2017. “Habitat–Performance Relationships of a Large Mammal on a Predator-Free Island Dominated by Humans.” Ecology and Evolution 7 (1): 305–19.\r\n\r\n\r\nBastille-Rousseau, Guillaume, Daniel Fortin, and Christian Dussault. 2010. “Inference from Habitat-Selection Analysis Depends on Foraging Strategies.” Journal of Animal Ecology 79 (6): 1157–63.\r\n\r\n\r\nBeyer, Hawthorne L, Daniel T Haydon, Juan M Morales, Jacqueline L Frair, Mark Hebblewhite, Michael Mitchell, and Jason Matthiopoulos. 2010. “The Interpretation of Habitat Preference Metrics Under Use–Availability Designs.” Philosophical Transactions of the Royal Society B: Biological Sciences 365 (1550): 2245–54.\r\n\r\n\r\nBoyce, Mark S, and Lyman L McDonald. 1999. “Relating Populations to Habitats Using Resource Selection Functions.” Trends in Ecology & Evolution 14 (7): 268–72.\r\n\r\n\r\nCharnov, Eric L. 1976. “Optimal Foraging, the Marginal Value Theorem.” Theoretical Population Biology 9 (2): 129–36.\r\n\r\n\r\nFretwell, S, and HL Lucas. 1969. “Territorial Behavior and Habitat Distribution in Birds. I. Theoretical Development.” Acta Biotheoretica.\r\n\r\n\r\nHalvorsen, Rune, Olav Skarpaas, Anders Bryn, Harald Bratli, Lars Erikstad, Trond Simensen, and Eva Lieungh. 2020. “Towards a Systematics of Ecodiversity: The EcoSyst Framework.” Global Ecology and Biogeography 29 (11): 1887–1906. https://doi.org/10.1111/geb.13164.\r\n\r\n\r\nHardy, AC. 1924. “The Herring in Relation to Its Animate Environment i. The Food and Feeding Habits of the Herring with Special Reference to the East Coast of England.” Fish. Invest., Lond. 2 (3): 53.\r\n\r\n\r\nHutchinson, G. E. 1958. “Concluding Remarks.” Cold Spring Harbor Symposia on Quantitative Biology 22: 415–27. https://doi.org/10.1101/SQB.1957.022.01.039.\r\n\r\n\r\nJohnson, Douglas H. 1980. “The Comparison of Usage and Availability Measurements for Evaluating Resource Preference.” Ecology 61 (1): 65–71.\r\n\r\n\r\nLele, Subhash R, Evelyn H Merrill, Jonah Keim, and Mark S Boyce. 2013. “Selection, Use, Choice and Occupancy: Clarifying Concepts in Resource Selection Studies.” Journal of Animal Ecology 82 (6): 1183–91.\r\n\r\n\r\nLosier, Chrystel L, Serge Couturier, Martin-Hugues St-Laurent, Pierre Drapeau, Claude Dussault, Tyler Rudolph, Vincent Brodeur, Jerod A Merkle, and Daniel Fortin. 2015. “Adjustments in Habitat Selection to Changing Availability Induce Fitness Costs for a Threatened Ungulate.” Journal of Applied Ecology 52 (2): 496–504.\r\n\r\n\r\nMacArthur, Robert H, and Eric R Pianka. 1966. “On Optimal Use of a Patchy Environment.” The American Naturalist 100 (916): 603–9.\r\n\r\n\r\nMcLoughlin, Philip D, Mark S Boyce, Tim Coulson, and Tim Clutton-Brock. 2006. “Lifetime Reproductive Success and Density-Dependent, Multi-Variable Resource Selection.” Proceedings of the Royal Society B: Biological Sciences 273 (1593): 1449–54.\r\n\r\n\r\nMelin, Markus, Juho Matala, Lauri Mehtätalo, Raisa Tiilikainen, Olli-Pekka Tikkanen, Matti Maltamo, Jyrki Pusenius, and Petteri Packalen. 2014. “Moose (a Lces Alces) Reacts to High Summer Temperatures by Utilizing Thermal Shelters in Boreal Forests–an Analysis Based on Airborne Laser Scanning of the Canopy Structure at Moose Locations.” Global Change Biology 20 (4): 1115–25.\r\n\r\n\r\nMorris, Douglas W. 1987. “Spatial Scale and the Cost of Density-Dependent Habitat Selection.” Evolutionary Ecology 1 (4): 379–88.\r\n\r\n\r\nMysterud, Atle, and Rolf Anker Ims. 1998. “Functional Responses in Habitat Use: Availability Influences Relative Use in Trade-Off Situations.” Ecology 79 (4): 1435–41.\r\n\r\n\r\nRettie, W James, and François Messier. 2000. “Hierarchical Habitat Selection by Woodland Caribou: Its Relationship to Limiting Factors.” Ecography 23 (4): 466–78.\r\n\r\n\r\nVan Moorter, Bram, Darcy Visscher, Ivar Herfindal, Mathieu Basille, and Atle Mysterud. 2013. “Inferring Behavioural Mechanisms in Habitat Selection Studies Getting the Null-Hypothesis Right for Functional and Familiarity Responses.” Ecography 36 (3): 323–30.\r\n\r\n\r\nWhittaker, R. H., S. A. Levin, and R. B. Root. 1973. “Niche, Habitat, and Ecotope.” The American Naturalist 107 (955): 321–38. https://doi.org/10.1086/282837.\r\n\r\n\r\nGAUSS, G. F., 1934, The struggle for existence. Balti- more, Williams & Wilkins. 163 pp, og VOLTERRA, V., 1926, Vartazioni e fluttuazioni del numero d’individui in specie animali conviventi. Mem. R. Accad. Lincei ser. 6, 2: 1-36↩︎\r\n",
    "preview": "posts/Nisje/Blog_nisje_files/figure-html5/fig1-1.png",
    "last_modified": "2022-01-03T20:27:30+01:00",
    "input_file": {}
  }
]
